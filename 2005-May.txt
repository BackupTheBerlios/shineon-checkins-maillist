From nobody at sheep.berlios.de  Sat May  7 11:48:08 2005
From: nobody at sheep.berlios.de (elitedev)
Date: Sat, 7 May 2005 11:48:08 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL ShineOn.RTL.chrome,1.3,1.4
Message-ID: <200505070948.j479m8m00910@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv29146/ShineOn.RTL

Modified Files:
	ShineOn.RTL.chrome 
Log Message:
Updated assemblyt referencer to use $(Framework)

Index: ShineOn.RTL.chrome
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/ShineOn.RTL.chrome,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** ShineOn.RTL.chrome	23 Apr 2005 11:26:26 -0000	1.3
--- ShineOn.RTL.chrome	7 May 2005 09:48:06 -0000	1.4
***************
*** 17,21 ****
      <Reference Assembly="$(Framework)\mscorlib.dll" Display="mscorlib" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
      <Reference Assembly="$(Framework)\System.dll" Display="System" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
!     <Reference Assembly="..\..\..\..\..\..\WINNT\Microsoft.NET\Framework\v1.1.4322\System.Drawing.dll" Display="System.Drawing.dll" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
    </References>
    <Configurations>
--- 17,21 ----
      <Reference Assembly="$(Framework)\mscorlib.dll" Display="mscorlib" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
      <Reference Assembly="$(Framework)\System.dll" Display="System" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
!     <Reference Assembly="$(Framework)\System.Drawing.dll" Display="System.Drawing" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
    </References>
    <Configurations>



From nobody at sheep.berlios.de  Sat May  7 11:56:49 2005
From: nobody at sheep.berlios.de (elitedev)
Date: Sat, 7 May 2005 11:56:49 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL.Win32 ShineOn.RTL.Win32.chrome,1.3,1.4
Message-ID: <200505070956.j479unm01018@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL.Win32
In directory sheep:/tmp/cvs-serv29697/ShineOn.RTL.Win32

Modified Files:
	ShineOn.RTL.Win32.chrome 
Log Message:
Updated assembly reference to use Project Reference

Index: ShineOn.RTL.Win32.chrome
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL.Win32/ShineOn.RTL.Win32.chrome,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** ShineOn.RTL.Win32.chrome	23 Apr 2005 11:26:26 -0000	1.3
--- ShineOn.RTL.Win32.chrome	7 May 2005 09:56:47 -0000	1.4
***************
*** 17,21 ****
      <Reference Assembly="$(Framework)\mscorlib.dll" Display="mscorlib" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
      <Reference Assembly="$(Framework)\System.dll" Display="System" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
!     <Reference Assembly="..\bin\ShineOn.RTL.dll" Display="ShineOn.RTL.dll" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
    </References>
    <Configurations>
--- 17,21 ----
      <Reference Assembly="$(Framework)\mscorlib.dll" Display="mscorlib" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
      <Reference Assembly="$(Framework)\System.dll" Display="System" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
!     <Reference Assembly="..\bin\shineon.rtl.dll" Display="ShineOn.RTL" ProjectReference="{EADE7853-FDBE-4770-B0B2-5FF5FDD2DBF7}|..\ShineOn.RTL\ShineOn.RTL.chrome" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
    </References>
    <Configurations>
***************
*** 34,37 ****
--- 34,38 ----
        <XmlDoc>False</XmlDoc>
        <XmlDocWarningLevel>WarningOnPublicMembers</XmlDocWarningLevel>
+       <EnableUnmanagedDebugging>False</EnableUnmanagedDebugging>
      </Configuration>
      <Configuration Name="Release">
***************
*** 49,52 ****
--- 50,54 ----
        <XmlDoc>False</XmlDoc>
        <XmlDocWarningLevel>WarningOnPublicMembers</XmlDocWarningLevel>
+       <EnableUnmanagedDebugging>False</EnableUnmanagedDebugging>
      </Configuration>
    </Configurations>



From nobody at sheep.berlios.de  Sat May  7 12:03:34 2005
From: nobody at sheep.berlios.de (elitedev)
Date: Sat, 7 May 2005 12:03:34 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL ShineOn.RTL.chrome,1.4,1.5
Message-ID: <200505071003.j47A3Ym01303@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv30248/ShineOn.RTL

Modified Files:
	ShineOn.RTL.chrome 
Log Message:
Project files alpha-sorted

Index: ShineOn.RTL.chrome
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/ShineOn.RTL.chrome,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** ShineOn.RTL.chrome	7 May 2005 09:48:06 -0000	1.4
--- ShineOn.RTL.chrome	7 May 2005 10:03:31 -0000	1.5
***************
*** 34,37 ****
--- 34,38 ----
        <XmlDoc>False</XmlDoc>
        <XmlDocWarningLevel>WarningOnPublicMembers</XmlDocWarningLevel>
+       <EnableUnmanagedDebugging>False</EnableUnmanagedDebugging>
      </Configuration>
      <Configuration Name="Release">
***************
*** 49,52 ****
--- 50,54 ----
        <XmlDoc>False</XmlDoc>
        <XmlDocWarningLevel>WarningOnPublicMembers</XmlDocWarningLevel>
+       <EnableUnmanagedDebugging>False</EnableUnmanagedDebugging>
      </Configuration>
    </Configurations>
***************
*** 68,84 ****
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="System.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="SysUtils.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="Types.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="IniFiles.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
--- 70,86 ----
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="IniFiles.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="System.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="SysUtils.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="Types.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>



From nobody at sheep.berlios.de  Sat May  7 18:44:40 2005
From: nobody at sheep.berlios.de (bscarr)
Date: Sat, 7 May 2005 18:44:40 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL SysUtils.pas,1.2,1.3
Message-ID: <200505071644.j47Giem15423@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv17808/ShineOn.RTL

Modified Files:
	SysUtils.pas 
Log Message:
Implemented and tested ExtractRelativePath

Index: SysUtils.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/SysUtils.pas,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** SysUtils.pas	25 Apr 2005 17:51:44 -0000	1.2
--- SysUtils.pas	7 May 2005 16:44:31 -0000	1.3
***************
*** 115,118 ****
--- 115,121 ----
  implementation
  
+ uses
+   System.Text;
+   
  procedure NotImplemented;
  begin
***************
*** 515,520 ****
  
  function ExtractRelativePath(const BaseName, DestName: string): string;
  begin
!   NotImplemented;
  end;
  
--- 518,552 ----
  
  function ExtractRelativePath(const BaseName, DestName: string): string;
+ var
+   baseTokens,
+   destTokens : array of String;
+   baseIdx    : Integer := 1;
+   destIdx    : Integer := 1;
+   builder    : StringBuilder;
  begin
!   result := DestName;
!   if SameFileName( ExtractFileDrive(BaseName), ExtractFileDrive(DestName) ) then begin
!     baseTokens := ExtractFileDir(BaseName).Split([System.IO.Path.DirectorySeparatorChar]);
!     destTokens := ExtractFileDir(DestName).Split([System.IO.Path.DirectorySeparatorChar]);
!     while (baseIdx < baseTokens.Length) and 
!           (destIdx < destTokens.Length) and 
!           SameFileName(baseTokens[baseIdx], destTokens[destIdx]) do begin
!       inc(baseIdx);
!       inc(destIdx);
!     end;
!     builder := new StringBuilder;
!     while baseIdx < baseTokens.Length do begin
!       builder.Append( '..' );
!       builder.Append( System.IO.Path.DirectorySeparatorChar );
!       inc(baseIdx);
!     end;
!     while destIdx < destTokens.Length do begin
!       builder.Append( destTokens[destIdx] );
!       builder.Append( System.IO.Path.DirectorySeparatorChar );
!       inc(destIdx);
!     end;
!     builder.Append( ExtractFileName(DestName) );
!     result := builder.ToString;
!   end;
  end;
  



From nobody at sheep.berlios.de  Sun May  8 12:54:51 2005
From: nobody at sheep.berlios.de (peter3)
Date: Sun, 8 May 2005 12:54:51 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL Classes.pas,1.2,1.3
Message-ID: <200505081054.j48Aspm08018@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv3633/ShineOn.RTL

Modified Files:
	Classes.pas 
Log Message:
TList.Assign implemented (from Jeroen Vandezande)

Index: Classes.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Classes.pas,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** Classes.pas	25 Apr 2005 17:51:44 -0000	1.2
--- Classes.pas	8 May 2005 10:54:47 -0000	1.3
***************
*** 13,16 ****
--- 13,17 ----
  // * implement all NotImplemented
  // * implement sorting and binary search in TStringlist
+ // * implement laSrcUnique and laDestUnique in the TList.Assign method | Jeroen Vandezande
  
  interface
***************
*** 81,84 ****
--- 82,87 ----
      procedure Sort(Compare: TListSortCompare);
      procedure Assign(ListA: TList; AOperator: TListAssignOp; ListB: TList);
+     procedure Assign(ListA: TList; AOperator: TListAssignOp);
+     procedure Assign(ListA: TList);
      property Capacity: Integer read GetCapacity write SetCapacity;
      property Count: Integer read GetCount write SetCount;
***************
*** 792,798 ****
  end;
  
  procedure TList.Assign(ListA: TList; AOperator: TListAssignOp; ListB: TList);
  begin
!   NotImplemented;
  end;
  
--- 795,861 ----
  end;
  
+ procedure TList.Assign(ListA: TList; AOperator: TListAssignOp);
+ begin
+   clear;
+   case AOperator of
+     TListAssignOp.LaCopy: //dest becomes a copy of the source, dest's original content is forgotten
+     begin
+       Clear;
+       List.AddRange(ListA.List);
+     end;
+     TListAssignOp.LaAnd: //intersection of the two lists
+     begin
+       for ThisListObject: Object in List do
+       begin
+         If not ListA.List.Contains(ThisListObject) then
+         begin
+           List.Remove(ThisListObject);  
+         end;
+       end;       
+     end;
+     TListAssignOp.LaOr: //union of the two lists
+     begin
+       for ListAObject: Object in ListA.List do
+       begin
+         If not List.Contains(ListAObject) then
+         begin
+           List.Add(ListAObject);  
+         end;
+       end;    
+     end;
+     TListAssignOp.LaXor:  //only those not in both lists
+     begin
+       for ListAObject: Object in ListA.List do
+       begin
+         If List.Contains(ListAObject) then
+         begin
+           List.Remove(ListAObject);  
+         end
+         else
+         begin
+           List.Add(ListAObject);
+         end;
+       end;    
+     end;
+     TListAssignOp.LaSrcUnique: //only those unique to source (same as laAnd followed by laXor, but faster)
+     begin
+       NotImplemented;  
+     end; 
+     TListAssignOp.LaDestUnique: //only those unique to dest (same as laOr followed by laXor, but faster)
+     begin
+       NotImplemented;  
+     end;    
+   End;  
+ end;
+ 
+ procedure TList.Assign(ListA: TList);
+ begin
+   Assign(ListA, TListAssignOp.LaCopy);  
+ end;
+ 
  procedure TList.Assign(ListA: TList; AOperator: TListAssignOp; ListB: TList);
  begin
!   Assign(ListA, TListAssignOp.laCopy);
!   Assign(ListB, AOperator);  
  end;
  



From nobody at sheep.berlios.de  Sun May  8 17:30:48 2005
From: nobody at sheep.berlios.de (loonquawl)
Date: Sun, 8 May 2005 17:30:48 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL Classes.pas,1.3,1.4
Message-ID: <200505081530.j48FUmm15156@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv1833/ShineOn.RTL

Modified Files:
	Classes.pas 
Log Message:
Finished the TList.Assign implementation.
Added LaSrcUnique and LaDestUnique.
TList.Assign is complete.

Index: Classes.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Classes.pas,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** Classes.pas	8 May 2005 10:54:47 -0000	1.3
--- Classes.pas	8 May 2005 15:30:46 -0000	1.4
***************
*** 13,17 ****
  // * implement all NotImplemented
  // * implement sorting and binary search in TStringlist
! // * implement laSrcUnique and laDestUnique in the TList.Assign method | Jeroen Vandezande
  
  interface
--- 13,19 ----
  // * implement all NotImplemented
  // * implement sorting and binary search in TStringlist
! 
! // HISTORY:
! // May 8 2005   :   Jeroen Vandezande   : Implemented TList.Assign
  
  interface
***************
*** 796,799 ****
--- 798,803 ----
  
  procedure TList.Assign(ListA: TList; AOperator: TListAssignOp);
+ Var
+   TempList: ArrayList;
  begin
    clear;
***************
*** 802,814 ****
      begin
        Clear;
!       List.AddRange(ListA.List);
      end;
      TListAssignOp.LaAnd: //intersection of the two lists
      begin
!       for ThisListObject: Object in List do
        begin
          If not ListA.List.Contains(ThisListObject) then
          begin
!           List.Remove(ThisListObject);  
          end;
        end;       
--- 806,818 ----
      begin
        Clear;
!       FList.AddRange(ListA.List);
      end;
      TListAssignOp.LaAnd: //intersection of the two lists
      begin
!       for ThisListObject: Object in FList do
        begin
          If not ListA.List.Contains(ThisListObject) then
          begin
!           FList.Remove(ThisListObject);  
          end;
        end;       
***************
*** 818,824 ****
        for ListAObject: Object in ListA.List do
        begin
!         If not List.Contains(ListAObject) then
          begin
!           List.Add(ListAObject);  
          end;
        end;    
--- 822,828 ----
        for ListAObject: Object in ListA.List do
        begin
!         If not FList.Contains(ListAObject) then
          begin
!           FList.Add(ListAObject);  
          end;
        end;    
***************
*** 828,848 ****
        for ListAObject: Object in ListA.List do
        begin
!         If List.Contains(ListAObject) then
          begin
!           List.Remove(ListAObject);  
          end
          else
          begin
!           List.Add(ListAObject);
          end;
        end;    
      end;
!     TListAssignOp.LaSrcUnique: //only those unique to source (same as laAnd followed by laXor, but faster)
      begin
!       NotImplemented;  
      end; 
!     TListAssignOp.LaDestUnique: //only those unique to dest (same as laOr followed by laXor, but faster)
      begin
!       NotImplemented;  
      end;    
    End;  
--- 832,866 ----
        for ListAObject: Object in ListA.List do
        begin
!         If FList.Contains(ListAObject) then
          begin
!           FList.Remove(ListAObject);  
          end
          else
          begin
!           FList.Add(ListAObject);
          end;
        end;    
      end;
!     TListAssignOp.LaSrcUnique: //Replaces the destination list with those elements of the source list that do not appear in the destination list. 
      begin
!       TempList := New ArrayList;
!       for ListAObject: Object in ListA.List do
!       begin
!         If not FList.Contains(ListAObject) then
!         begin
!           TempList.Add(ListAObject);  
!         end;
!         FList := TempList;
!       end;  
      end; 
!     TListAssignOp.LaDestUnique: //Removes all elements from the destination list that appear in the source list. The destination list ends up containing the elements unique to the original destination list
      begin
!       for ThisListObject: Object in FList do
!       begin
!         If ListA.List.Contains(ThisListObject) then
!         begin
!           FList.Remove(ThisListObject);  
!         end;
!       end;  
      end;    
    End;  



From nobody at sheep.berlios.de  Wed May 11 01:04:47 2005
From: nobody at sheep.berlios.de (loonquawl)
Date: Wed, 11 May 2005 01:04:47 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL SysUtils.pas,1.4,1.5
Message-ID: <200505102304.j4AN4lm16161@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv17193/ShineOn.RTL

Modified Files:
	SysUtils.pas 
Log Message:
fixed the TReplaceFlags set.
was wronly changed to a set of an enumeration. but that proved wrong.
So this reverts the type to it's original state.

Index: SysUtils.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/SysUtils.pas,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** SysUtils.pas	10 May 2005 21:52:16 -0000	1.4
--- SysUtils.pas	10 May 2005 23:04:43 -0000	1.5
***************
*** 101,108 ****
  function AnsiStrScan(Str: string; Chr: Char): string;
  
! type
!   TReplaceFlag = public (rfReplaceAll, rfIgnoreCase);
! 
!   TReplaceFlags = public set of TReplaceFlag;
  
  function StringReplace(const S, OldPattern, NewPattern: string;
--- 101,106 ----
  function AnsiStrScan(Str: string; Chr: Char): string;
  
! type  
!   TReplaceFlags = public set of (rfReplaceAll, rfIgnoreCase);
  
  function StringReplace(const S, OldPattern, NewPattern: string;
***************
*** 719,723 ****
    tempRegex: Regex;
  begin
!   if TReplaceFlag.rfIgnoreCase in Flags then
    begin
      tempRegex := new Regex(OldPattern, RegexOptions.IgnoreCase);
--- 717,721 ----
    tempRegex: Regex;
  begin
!   if TReplaceFlags.rfIgnoreCase in Flags then
    begin
      tempRegex := new Regex(OldPattern, RegexOptions.IgnoreCase);
***************
*** 727,731 ****
      tempRegex := new Regex(OldPattern);
    end;
!   if TReplaceFlag.rfReplaceAll in Flags then
    begin
     Result := tempRegex.Replace(S,NewPattern);
--- 725,729 ----
      tempRegex := new Regex(OldPattern);
    end;
!   if TReplaceFlags.rfReplaceAll in Flags then
    begin
     Result := tempRegex.Replace(S,NewPattern);



From nobody at sheep.berlios.de  Tue May 17 00:05:38 2005
From: nobody at sheep.berlios.de (peter3)
Date: Tue, 17 May 2005 00:05:38 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL Classes.pas,1.5,1.6 Contnrs.pas,1.2,1.3 SysUtils.pas,1.5,1.6 System.pas,1.2,1.3 Types.pas,1.3,1.4
Message-ID: <200505162205.j4GM5cm12773@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv4051/ShineOn.RTL

Modified Files:
	Classes.pas Contnrs.pas SysUtils.pas System.pas Types.pas 
Log Message:
- All global procedures are now wrappers for public class methods
- All enums replaced by enum/consts combo so Delphi porters don't have to qualify with the enum type
- Added Pred, Succ and Odd

Index: Classes.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Classes.pas,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** Classes.pas	11 May 2005 18:12:37 -0000	1.5
--- Classes.pas	16 May 2005 22:05:36 -0000	1.6
***************
*** 37,43 ****
    TListSortCompare = public function (Item1, Item2: Object): Integer;
    
!   TListNotification = public (lnAdded, lnExtracted, lnDeleted);
!   TListAssignOp = public (laCopy, laAnd, laOr, laXor, laSrcUnique, laDestUnique);
    
    TListSortCompareWrapper = assembly class(TObject, IComparer)
    private
--- 37,57 ----
    TListSortCompare = public function (Item1, Item2: Object): Integer;
    
!   TListNotification = public (Added, Extracted, Deleted);
! const
!   lnAdded = TListNotification.Added;
!   lnExtracted = TListNotification.Extracted;
!   lnDeleted  = TListNotification.Deleted;
    
+ type   
+   TListAssignOp = public (Copy, &And, &Or, &Xor, SrcUnique, DestUnique);
+ const  
+   laCopy = TListAssignOp.Copy;
+   laAnd = TListAssignOp.&And;
+   laOr = TListAssignOp.&Or;
+   laXor = TListAssignOp.&Xor;
+   laSrcUnique = TListAssignOp.SrcUnique;
+   laDestUnique = TListAssignOp.DestUnique;
+   
+ type  
    TListSortCompareWrapper = assembly class(TObject, IComparer)
    private
***************
*** 478,483 ****
    TThreadMethod = public procedure of object;
  
!   TThreadPriority = public (tpIdle, tpLowest, tpLower, tpNormal, tpHigher, tpHighest, tpTimeCritical);
! 
    TThread = public class
    private
--- 492,507 ----
    TThreadMethod = public procedure of object;
  
!   TThreadPriority = public (Idle, Lowest, Lower, Normal, Higher, Highest, TimeCritical);
!   
! const
!   tpIdle = TThreadPriority.Idle;
!   tpLowest = TThreadPriority.Lowest;
!   tpLower = TThreadPriority.Lower;
!   tpNormal = TThreadPriority.Normal;
!   tpHigher = TThreadPriority.Higher;
!   tpHighest = TThreadPriority.Highest;
!   tpTimeCritical = TThreadPriority.TimeCritical;
!   
! type  
    TThread = public class
    private
***************
*** 657,663 ****
      FList[Index] := Value;
      if Temp <> nil then
!       Notify(Temp, TListNotification.lnDeleted);
      if Value <> nil then
!       Notify(Value, TListNotification.lnAdded);
    end;
  end;
--- 681,687 ----
      FList[Index] := Value;
      if Temp <> nil then
!       Notify(Temp, TListNotification.Deleted);
      if Value <> nil then
!       Notify(Value, TListNotification.Added);
    end;
  end;
***************
*** 683,687 ****
    Result := FList.Add(Item);
    if Item <> nil then
!     Notify(Item, TListNotification.lnAdded);
  end;
  
--- 707,711 ----
    Result := FList.Add(Item);
    if Item <> nil then
!     Notify(Item, TListNotification.Added);
  end;
  
***************
*** 699,703 ****
    FList.RemoveAt(Index);
    if Temp <> nil then
!     Notify(Temp, TListNotification.lnDeleted);
  end;
  
--- 723,727 ----
    FList.RemoveAt(Index);
    if Temp <> nil then
!     Notify(Temp, TListNotification.Deleted);
  end;
  
***************
*** 732,736 ****
      FList[I] := nil;
      Delete(I);
!     Notify(Result, TListNotification.lnExtracted);
    end;
  end;
--- 756,760 ----
      FList[I] := nil;
      Delete(I);
!     Notify(Result, TListNotification.Extracted);
    end;
  end;
***************
*** 752,756 ****
    FList.Insert(Index, Item);
    if Item <> nil then
!     Notify(Item, TListNotification.lnAdded);
  end;
  
--- 776,780 ----
    FList.Insert(Index, Item);
    if Item <> nil then
!     Notify(Item, TListNotification.Added);
  end;
  
***************
*** 809,818 ****
    clear;
    case AOperator of
!     TListAssignOp.LaCopy: //dest becomes a copy of the source, dest's original content is forgotten
      begin
        Clear;
        FList.AddRange(ListA.List);
      end;
!     TListAssignOp.LaAnd: //intersection of the two lists
      begin
        for ThisListObject: Object in FList do
--- 833,842 ----
    clear;
    case AOperator of
!     TListAssignOp.Copy: //dest becomes a copy of the source, dest's original content is forgotten
      begin
        Clear;
        FList.AddRange(ListA.List);
      end;
!     TListAssignOp.And: //intersection of the two lists
      begin
        for ThisListObject: Object in FList do
***************
*** 824,828 ****
        end;       
      end;
!     TListAssignOp.LaOr: //union of the two lists
      begin
        for ListAObject: Object in ListA.List do
--- 848,852 ----
        end;       
      end;
!     TListAssignOp.Or: //union of the two lists
      begin
        for ListAObject: Object in ListA.List do
***************
*** 834,838 ****
        end;    
      end;
!     TListAssignOp.LaXor:  //only those not in both lists
      begin
        for ListAObject: Object in ListA.List do
--- 858,862 ----
        end;    
      end;
!     TListAssignOp.Xor:  //only those not in both lists
      begin
        for ListAObject: Object in ListA.List do
***************
*** 848,852 ****
        end;    
      end;
!     TListAssignOp.LaSrcUnique: //Replaces the destination list with those elements of the source list that do not appear in the destination list. 
      begin
        TempList := New ArrayList;
--- 872,876 ----
        end;    
      end;
!     TListAssignOp.SrcUnique: //Replaces the destination list with those elements of the source list that do not appear in the destination list. 
      begin
        TempList := New ArrayList;
***************
*** 860,864 ****
        end;  
      end; 
!     TListAssignOp.LaDestUnique: //Removes all elements from the destination list that appear in the source list. The destination list ends up containing the elements unique to the original destination list
      begin
        for ThisListObject: Object in FList do
--- 884,888 ----
        end;  
      end; 
!     TListAssignOp.DestUnique: //Removes all elements from the destination list that appear in the source list. The destination list ends up containing the elements unique to the original destination list
      begin
        for ThisListObject: Object in FList do
***************
*** 875,884 ****
  procedure TList.Assign(ListA: TList);
  begin
!   Assign(ListA, TListAssignOp.LaCopy);  
  end;
  
  procedure TList.Assign(ListA: TList; AOperator: TListAssignOp; ListB: TList);
  begin
!   Assign(ListA, TListAssignOp.laCopy);
    Assign(ListB, AOperator);  
  end;
--- 899,908 ----
  procedure TList.Assign(ListA: TList);
  begin
!   Assign(ListA, TListAssignOp.Copy);  
  end;
  
  procedure TList.Assign(ListA: TList; AOperator: TListAssignOp; ListB: TList);
  begin
!   Assign(ListA, TListAssignOp.Copy);
    Assign(ListB, AOperator);  
  end;
***************
*** 897,903 ****
    LockList;
    try
!     if (Duplicates = TDuplicates.dupAccept) or (FList.IndexOf(Item) < 0) then
        FList.Add(Item)
!     else if Duplicates = TDuplicates.dupError then
        FList.Error(SDuplicateItem, Integer(Item));
    finally
--- 921,927 ----
    LockList;
    try
!     if (Duplicates = TDuplicates.Accept) or (FList.IndexOf(Item) < 0) then
        FList.Add(Item)
!     else if Duplicates = TDuplicates.Error then
        FList.Error(SDuplicateItem, Integer(Item));
    finally
***************
*** 2079,2083 ****
  begin
    Result := DataString.SubString(0, Count);
!   Seek(Result.Length, TSeekOrigin.soCurrent);
  end;
  
--- 2103,2107 ----
  begin
    Result := DataString.SubString(0, Count);
!   Seek(Result.Length, TSeekOrigin.Current);
  end;
  
***************
*** 2085,2093 ****
  begin
    case Origin of
!     TSeekOrigin.soBeginning: 
        FPosition := Offset;
!     TSeekOrigin.soCurrent: 
        FPosition := FPosition + Offset;
!     TSeekOrigin.soEnd: 
        FPosition := DataString.Length - Offset;
    end;
--- 2109,2117 ----
  begin
    case Origin of
!     TSeekOrigin.Beginning: 
        FPosition := Offset;
!     TSeekOrigin.Current: 
        FPosition := FPosition + Offset;
!     TSeekOrigin.End: 
        FPosition := DataString.Length - Offset;
    end;
***************
*** 2175,2187 ****
    case FThread.Priority of
      ThreadPriority.Lowest:
!       Result := TThreadPriority.tpLowest;
      ThreadPriority.BelowNormal:
!       Result := TThreadPriority.tpLower;
      ThreadPriority.Normal:
!       Result := TThreadPriority.tpNormal;
      ThreadPriority.AboveNormal:
!       Result := TThreadPriority.tpHigher;
      ThreadPriority.Highest:
!       Result := TThreadPriority.tpHighest;
    end; // case
  end;
--- 2199,2211 ----
    case FThread.Priority of
      ThreadPriority.Lowest:
!       Result := TThreadPriority.Lowest;
      ThreadPriority.BelowNormal:
!       Result := TThreadPriority.Lower;
      ThreadPriority.Normal:
!       Result := TThreadPriority.Normal;
      ThreadPriority.AboveNormal:
!       Result := TThreadPriority.Higher;
      ThreadPriority.Highest:
!       Result := TThreadPriority.Highest;
    end; // case
  end;
***************
*** 2190,2202 ****
  begin
    case Value of
!     TThreadPriority.tpIdle, TThreadPriority.tpLowest:
        FThread.Priority := ThreadPriority.Lowest;
!     TThreadPriority.tpLower:
        FThread.Priority := ThreadPriority.BelowNormal;
!     TThreadPriority.tpNormal:
        FThread.Priority := ThreadPriority.Normal;
!     TThreadPriority.tpHigher:
        FThread.Priority := ThreadPriority.AboveNormal;
!     TThreadPriority.tpHighest, TThreadPriority.tpTimeCritical:
        FThread.Priority := ThreadPriority.Highest;
    end; // case
--- 2214,2226 ----
  begin
    case Value of
!     TThreadPriority.Idle, TThreadPriority.Lowest:
        FThread.Priority := ThreadPriority.Lowest;
!     TThreadPriority.Lower:
        FThread.Priority := ThreadPriority.BelowNormal;
!     TThreadPriority.Normal:
        FThread.Priority := ThreadPriority.Normal;
!     TThreadPriority.Higher:
        FThread.Priority := ThreadPriority.AboveNormal;
!     TThreadPriority.Highest, TThreadPriority.TimeCritical:
        FThread.Priority := ThreadPriority.Highest;
    end; // case

Index: Contnrs.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Contnrs.pas,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** Contnrs.pas	25 Apr 2005 17:51:44 -0000	1.2
--- Contnrs.pas	16 May 2005 22:05:36 -0000	1.3
***************
*** 152,163 ****
  { TBucketList }
  
!   TBucketListSizes = public (bl2, bl4, bl8, bl16, bl32, bl64, bl128, bl256);
! 
    TBucketList = public class(TCustomBucketList)
    public
!     constructor Create(ABuckets: TBucketListSizes := TBucketListSizes.bl16);
    end;
  
- 
  { TObjectBucketList }
  
--- 152,173 ----
  { TBucketList }
  
!   TBucketListSizes = public (BucketSize2, BucketSize4, BucketSize8, BucketSize16, BucketSize32, BucketSize64, BucketSize128, BucketSize256);
!   
! const  
!   bl2 = TBucketListSizes.BucketSize2;
!   bl4 = TBucketListSizes.BucketSize4;
!   bl8 = TBucketListSizes.BucketSize8;
!   bl16 = TBucketListSizes.BucketSize16;
!   bl32 = TBucketListSizes.BucketSize32;
!   bl64 = TBucketListSizes.BucketSize64;
!   bl128 = TBucketListSizes.BucketSize128;
!   bl256 = TBucketListSizes.BucketSize256;
!   
! type
    TBucketList = public class(TCustomBucketList)
    public
!     constructor Create(ABuckets: TBucketListSizes := TBucketListSizes.BucketSize16);
    end;
  
  { TObjectBucketList }
  
***************
*** 244,248 ****
  begin
    if OwnsObjects then
!     if (Action = TListNotification.lnDeleted) and (Ptr is TObject) then
        TObject(Ptr).Free;
    inherited Notify(Ptr, Action);
--- 254,258 ----
  begin
    if OwnsObjects then
!     if (Action = TListNotification.Deleted) and (Ptr is TObject) then
        TObject(Ptr).Free;
    inherited Notify(Ptr, Action);

Index: SysUtils.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/SysUtils.pas,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** SysUtils.pas	10 May 2005 23:04:43 -0000	1.5
--- SysUtils.pas	16 May 2005 22:05:36 -0000	1.6
***************
*** 15,18 ****
--- 15,113 ----
  interface
  
+ type
+   EShineOnError = public class(Exception);
+   TReplaceFlags = public set of (ReplaceAll, IgnoreCase);
+   
+ const
+   rfReplaceAll = TReplaceFlags.ReplaceAll;
+   rfIgnoreCase = TReplaceFlags.IgnoreCase;
[...1557 lines suppressed...]
+   Result := ShineOn.RTL.SysUtils.AnsiStrRScan(Str, Chr);
+ end;
+   
+ function AnsiStrScan(Str: string; Chr: Char): string;
+ begin
+   Result := ShineOn.RTL.SysUtils.AnsiStrScan(Str, Chr);
+ end;
+   
+ function StringReplace(const S, OldPattern, NewPattern: string; Flags: TReplaceFlags): string;
+ begin
+   Result := ShineOn.RTL.SysUtils.StringReplace(S, OldPattern, NewPattern, Flags);
+ end;
+   
+ function GetEnvironmentVariable(const Name: string): string;   
+ begin
+   Result := ShineOn.RTL.SysUtils.GetEnvironmentVariable(Name);
+ end;
+   
  
    

Index: System.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/System.pas,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** System.pas	25 Apr 2005 17:51:44 -0000	1.2
--- System.pas	16 May 2005 22:05:36 -0000	1.3
***************
*** 15,19 ****
--- 15,63 ----
    System.Globalization;  
    
+ type
+   System = public sealed class 
+   public
+     class function Pos(const SubStr, Str:string):integer;
+     class function Concat(const S1, S2:string):string;
+     class procedure Delete(var S: string; Index, Count:Integer);
+     class procedure Insert(const Source: string; var S: string; Index: Integer);
+     class function Copy(const Source:string; StartIndex, Length: Integer):string;
+ 
+     class procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
+     class procedure Val(const S:string; var V:Double; var Code: Integer);
+ 
+     class function Ord(Value:Char):integer;
+     class function Ord(Value:Boolean):integer;
+ 
+     class procedure Inc(var Value:integer);
+     class procedure Inc(var Value:integer; Amount:integer);
+     class procedure Dec(var Value:integer);
+     class procedure Dec(var Value:integer; Amount:integer);
+     class function Pred(Value:Integer):Integer;
+     class function Succ(Value:Integer):Integer;
  
+     class function Round(Value:Double):Integer;
+     class function Round(Value:TDateTime):Integer;
+     class function Trunc(Value:Double):Integer;
+     class function Trunc(Value:TDateTime):Integer;
+     class function Int(X: Double): Double;
+     class function Int(X: TDateTime): Double;
+     class function Frac(Value:Double):Double;
+     class function Frac(Value:TDateTime):Double;
+     class function Odd(Value:Integer):boolean;
+ 
+     // TODO: add more overloads
+     class function Abs(X:Integer):Integer;
+     class function Abs(X:Double):Double;
+     class function Abs(X:TDateTime):TDateTime;
+     class function Exp(X: Double): Double;
+ 
+     class procedure SetLength(var S; Length: integer);
+     class procedure Write(const S:string);
+     class procedure WriteLn(const S:string);
+     class procedure Read(var P);
+     class procedure ReadLn(var P);
+   end;
+   
  function Pos(const SubStr, Str:string):integer;
  function Concat(const S1, S2:string):string;
***************
*** 21,37 ****
  procedure Insert(const Source: string; var S: string; Index: Integer);
  function Copy(const Source:string; StartIndex, Length: Integer):string;
- 
  procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
  procedure Val(const S:string; var V:Double; var Code: Integer);
- 
- // these should be overloaded with other ordinal types
  function Ord(Value:Char):integer;
  function Ord(Value:Boolean):integer;
- 
  procedure Inc(var Value:integer);
  procedure Inc(var Value:integer; Amount:integer);
  procedure Dec(var Value:integer);
  procedure Dec(var Value:integer; Amount:integer);
! 
  function Round(Value:Double):Integer;
  function Round(Value:TDateTime):Integer;
--- 65,78 ----
  procedure Insert(const Source: string; var S: string; Index: Integer);
  function Copy(const Source:string; StartIndex, Length: Integer):string;
  procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
  procedure Val(const S:string; var V:Double; var Code: Integer);
  function Ord(Value:Char):integer;
  function Ord(Value:Boolean):integer;
  procedure Inc(var Value:integer);
  procedure Inc(var Value:integer; Amount:integer);
  procedure Dec(var Value:integer);
  procedure Dec(var Value:integer; Amount:integer);
! function Pred(Value:Integer):Integer;
! function Succ(Value:Integer):Integer;
  function Round(Value:Double):Integer;
  function Round(Value:TDateTime):Integer;
***************
*** 42,52 ****
  function Frac(Value:Double):Double;
  function Frac(Value:TDateTime):Double;
! 
! // TODO: add more overloads
  function Abs(X:Integer):Integer;
  function Abs(X:Double):Double;
  function Abs(X:TDateTime):TDateTime;
  function Exp(X: Double): Double;
- 
  procedure SetLength(var S; Length: integer);
  procedure Write(const S:string);
--- 83,91 ----
  function Frac(Value:Double):Double;
  function Frac(Value:TDateTime):Double;
! function Odd(Value:Integer):boolean;
  function Abs(X:Integer):Integer;
  function Abs(X:Double):Double;
  function Abs(X:TDateTime):TDateTime;
  function Exp(X: Double): Double;
  procedure SetLength(var S; Length: integer);
  procedure Write(const S:string);
***************
*** 59,63 ****
  
  
! function Pos(const SubStr, Str:string):integer;
  begin
    //TODO: Should this function return 0 or -1 if substr not found?
--- 98,102 ----
  
  
! class function System.Pos(const SubStr, Str:string):integer;
  begin
    //TODO: Should this function return 0 or -1 if substr not found?
***************
*** 65,84 ****
  end;
  
! function Concat(const S1, S2:string):string;
  begin
    Result := S1 + S2;
  end;
  
! procedure Delete(var S: string; Index, Count:Integer);
  begin
    S := S.SubString(Index, Count);
  end;
  
! procedure Insert(Source: string; var S: string; Index: Integer);
  begin
    S := Source.Substring(0, Index) + S + Source.Substring(Index + 1);
  end;
  
! function Copy(const Source:string; StartIndex, Length: Integer):string;
  begin
    if Source = nil then
--- 104,123 ----
  end;
  
! class function System.Concat(const S1, S2:string):string;
  begin
    Result := S1 + S2;
  end;
  
! class procedure System.Delete(var S: string; Index, Count:Integer);
  begin
    S := S.SubString(Index, Count);
  end;
  
! class procedure System.Insert(Source: string; var S: string; Index: Integer);
  begin
    S := Source.Substring(0, Index) + S + Source.Substring(Index + 1);
  end;
  
! class function System.Copy(const Source:string; StartIndex, Length: Integer):string;
  begin
    if Source = nil then
***************
*** 88,97 ****
  end;
  
! procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
  begin
    X.ToString(Width.ToString + '.' + Decimals.ToString);
  end;
  
! procedure Val(const S:string; var V:Double; var Code: Integer);
  begin
    // TODO: should we use NumberFormatInfo.CurrentInfo here?
--- 127,136 ----
  end;
  
! class procedure System.Str(X:Double; Width:integer;Decimals:integer;var S:string);
  begin
    X.ToString(Width.ToString + '.' + Decimals.ToString);
  end;
  
! class procedure System.Val(const S:string; var V:Double; var Code: Integer);
  begin
    // TODO: should we use NumberFormatInfo.CurrentInfo here?
***************
*** 102,111 ****
  end;
  
! function Ord(Value:Char):integer;
  begin
    Result := integer(Value);
  end;
  
! function Ord(Value:Boolean):integer;
  begin
    if Value then
--- 141,150 ----
  end;
  
! class function System.Ord(Value:Char):integer;
  begin
    Result := integer(Value);
  end;
  
! class function System.Ord(Value:Boolean):integer;
  begin
    if Value then
***************
*** 115,169 ****
  end;
  
! procedure Inc(var Value:integer);
  begin
    Value := Value + 1;
  end;
  
! procedure Inc(var Value:integer; Amount:integer);
  begin
    Value := Value + Amount;
  end;
  
! procedure Dec(var Value:integer);
  begin
    Value := Value - 1;
  end;
  
! procedure Dec(var Value:integer; Amount:integer);
  begin
    Value := Value - Amount;
  end;
  
! function Round(Value:Double):Integer;
  begin
    Result := Convert.ToInt32(Value);
  end;
  
! function Round(Value:TDateTime):Integer;
  begin
    Result := Round(Value.Value);
  end;
    
! function Trunc(Value:Double):Integer;
  begin
    Result := Integer(Value);
  end;
  
! function Trunc(Value:TDateTime):Integer;
  begin
    Result := Value.Date
  end;
  
! function Int(X: Double): Double;
  begin
    Result := Integer(X);
  end;  
  
! function Int(X: TDateTime): Double;
  begin
    Result := X.Date;
  end;  
  
! function Frac(Value:Double):Double;
  begin
    Result := Abs(Value) - Integer(Abs(Value));
--- 154,218 ----
  end;
  
! class procedure System.Inc(var Value:integer);
  begin
    Value := Value + 1;
  end;
  
! class procedure System.Inc(var Value:integer; Amount:integer);
  begin
    Value := Value + Amount;
  end;
  
! class procedure System.Dec(var Value:integer);
  begin
    Value := Value - 1;
  end;
  
! class procedure System.Dec(var Value:integer; Amount:integer);
  begin
    Value := Value - Amount;
  end;
  
! class function System.Pred(Value:Integer):Integer;
! begin
!   Result := Value - 1;
! end;
! 
! class function System.Succ(Value:Integer):Integer;
! begin
!   Result := Value + 1;
! end;
! 
! class function System.Round(Value:Double):Integer;
  begin
    Result := Convert.ToInt32(Value);
  end;
  
! class function System.Round(Value:TDateTime):Integer;
  begin
    Result := Round(Value.Value);
  end;
    
! class function System.Trunc(Value:Double):Integer;
  begin
    Result := Integer(Value);
  end;
  
! class function System.Trunc(Value:TDateTime):Integer;
  begin
    Result := Value.Date
  end;
  
! class function System.Int(X: Double): Double;
  begin
    Result := Integer(X);
  end;  
  
! class function System.Int(X: TDateTime): Double;
  begin
    Result := X.Date;
  end;  
  
! class function System.Frac(Value:Double):Double;
  begin
    Result := Abs(Value) - Integer(Abs(Value));
***************
*** 172,201 ****
  end;
  
! function Frac(Value:TDateTime):Double;
  begin
    Result := Value.Time;
  end;
  
! function Abs(X:Integer):Integer;
  begin
    Result := Math.Abs(X);
  end;
  
! function Abs(X:Double):Double;
  begin
    Result := Math.Abs(X);
  end;
  
! function Abs(X:TDateTime):TDateTime;
  begin
    Result := new TDateTime(Abs(X.Value));
  end;
  
! function Exp(X: Double): Double;
  begin
    Result := Math.Exp(X);
  end;  
  
! procedure SetLength(var S; Length: integer);
  require
    Assigned(S);
--- 221,255 ----
  end;
  
! class function System.Frac(Value:TDateTime):Double;
  begin
    Result := Value.Time;
  end;
  
! class function System.Odd(Value:Integer):boolean;
! begin
!   Result := Value and 1 <> 0;
! end;
! 
! class function System.Abs(X:Integer):Integer;
  begin
    Result := Math.Abs(X);
  end;
  
! class function System.Abs(X:Double):Double;
  begin
    Result := Math.Abs(X);
  end;
  
! class function System.Abs(X:TDateTime):TDateTime;
  begin
    Result := new TDateTime(Abs(X.Value));
  end;
  
! class function System.Exp(X: Double): Double;
  begin
    Result := Math.Exp(X);
  end;  
  
! class procedure System.SetLength(var S; Length: integer);
  require
    Assigned(S);
***************
*** 224,238 ****
  end;
  
! procedure WriteLn(const S:string);
  begin
    Console.WriteLine(S);
  end;
  
! procedure Write(const S:string);
  begin
    Console.Write(S);
  end;
  
! procedure Read(var P);
  begin
    var i:integer := Console.Read;
--- 278,292 ----
  end;
  
! class procedure System.WriteLn(const S:string);
  begin
    Console.WriteLine(S);
  end;
  
! class procedure System.Write(const S:string);
  begin
    Console.Write(S);
  end;
  
! class procedure System.Read(var P);
  begin
    var i:integer := Console.Read;
***************
*** 243,250 ****
  end;
  
! procedure ReadLn(var P);
  begin
    P := Console.ReadLine;
  end;
  
  end.
--- 297,473 ----
  end;
  
! class procedure System.ReadLn(var P);
  begin
    P := Console.ReadLine;
  end;
+ 
+ // DELPHI COMPATIBLE GLOBAL METHODS
+ 
+ function Pos(const SubStr, Str:string):integer;
+ begin
+   Result := ShineOn.RTL.System.Pos(SubStr, Str);
+ end;
+   
+ function Concat(const S1, S2:string):string;
+ begin
+   Result := ShineOn.RTL.System.Concat(S1, S2);
+ end;
+   
+ procedure Delete(var S: string; Index, Count:Integer);
+ begin
+   ShineOn.RTL.System.Delete(S, Index, Count);
+ end;
+   
+ procedure Insert(const Source: string; var S: string; Index: Integer);
+ begin
+   ShineOn.RTL.System.Insert(Source, S, Index);
+ end;
+   
+ function Copy(const Source:string; StartIndex, Length: Integer):string;
+ begin
+   Result := ShineOn.RTL.System.Copy(Source, StartIndex, Length);
+ end;
+   
+ procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
+ begin
+   ShineOn.RTL.System.Str(X, Width, Decimals, S);
+ end;
+   
+ procedure Val(const S:string; var V:Double; var Code: Integer);
+ begin
+   ShineOn.RTL.System.Val(S, V, Code);
+ end;
+   
+ function Ord(Value:Char):integer;
+ begin
+   Result := ShineOn.RTL.System.Ord(Value);
+ end;
+   
+ function Ord(Value:Boolean):integer;
+ begin
+   Result := ShineOn.RTL.System.Ord(Value);
+ end;
+   
+ procedure Inc(var Value:integer);
+ begin
+   ShineOn.RTL.System.Inc(Value);
+ end;
+   
+ procedure Inc(var Value:integer; Amount:integer);
+ begin
+   ShineOn.RTL.System.Inc(Value, Amount);
+ end;
+   
+ procedure Dec(var Value:integer);
+ begin
+   ShineOn.RTL.System.Dec(Value);
+ end;
+   
+ procedure Dec(var Value:integer; Amount:integer);
+ begin
+   ShineOn.RTL.System.Dec(Value, Amount);
+ end;
+   
+ function Pred(Value:Integer):Integer;
+ begin
+   Result := ShineOn.RTL.System.Pred(Value);
+ end;
+   
+ function Succ(Value:Integer):Integer;
+ begin
+   Result := ShineOn.RTL.System.Succ(Value);
+ end;
+    
+ function Round(Value:Double):Integer;
+ begin
+   Result := ShineOn.RTL.System.Round(Value);
+ end;
+   
+ function Round(Value:TDateTime):Integer;
+ begin
+   Result := ShineOn.RTL.System.Round(Value);
+ end;
+   
+ function Trunc(Value:Double):Integer;
+ begin
+   Result := ShineOn.RTL.System.Trunc(Value);
+ end;
+   
+ function Trunc(Value:TDateTime):Integer;
+ begin
+   Result := ShineOn.RTL.System.Trunc(Value);
+ end;
+   
+ function Int(X: Double): Double;
+ begin
+   Result := ShineOn.RTL.System.Int(X);
+ end;
+   
+ function Int(X: TDateTime): Double;
+ begin
+   Result := ShineOn.RTL.System.Int(X);
+ end;
+   
+ function Frac(Value:Double):Double;
+ begin
+   Result := ShineOn.RTL.System.Frac(Value);
+ end;
+   
+ function Frac(Value:TDateTime):Double;
+ begin
+   Result := ShineOn.RTL.System.Frac(Value);
+ end;
+   
+ function Odd(Value:Integer):boolean;
+ begin
+   Result := ShineOn.RTL.System.Odd(Value);
+ end;
+   
+ function Abs(X:Integer):Integer;
+ begin
+   Result := ShineOn.RTL.System.Abs(X);
+ end;
+   
+ function Abs(X:Double):Double;
+ begin
+   Result := ShineOn.RTL.System.Abs(X);
+ end;
+   
+ function Abs(X:TDateTime):TDateTime;
+ begin
+   Result := ShineOn.RTL.System.Abs(X);
+ end;
+   
+ function Exp(X: Double): Double;
+ begin
+   Result := ShineOn.RTL.System.Exp(X);
+ end;
+   
+ procedure SetLength(var S; Length: integer);
+ begin
+   ShineOn.RTL.System.SetLength(S, Length);
+ end;
+   
+ procedure Write(const S:string);
+ begin
+   ShineOn.RTL.System.Write(S);
+ end;
+   
+ procedure WriteLn(const S:string);
+ begin
+   ShineOn.RTL.System.WriteLn(S);
+ end;
+   
+ procedure Read(var P);
+ begin
+   ShineOn.RTL.System.Read(P);
+ end;
+   
+ procedure ReadLn(var P);
+ begin
+   ShineOn.RTL.System.ReadLn(P);
+ end;
+   
+ 
  
  end.

Index: Types.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Types.pas,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** Types.pas	25 Apr 2005 17:51:44 -0000	1.3
--- Types.pas	16 May 2005 22:05:36 -0000	1.4
***************
*** 27,31 ****
  type
  { TStream seek origins }
!   TSeekOrigin = public (soBeginning, soCurrent, soEnd);
    HRESULT = Longint;
  
--- 27,37 ----
  type
  { TStream seek origins }
!   TSeekOrigin = public (Beginning, Current, &End);
! const
!   soBeginning = TSeekOrigin.Beginning;
!   soCurrent = TSeekOrigin.Current;
!   soEnd = TSeekOrigin.End;
! 
! type  
    HRESULT = Longint;
  
***************
*** 212,226 ****
  { Text alignment types }
  
!   TAlignment = public (taLeftJustify, taRightJustify, taCenter);
  //!!!  TLeftRight = taLeftJustify..taRightJustify; // not supported by Chrome
!   TBiDiMode = public (bdLeftToRight, bdRightToLeft, bdRightToLeftNoAlign, bdRightToLeftReadingOnly);
  
  { Types used by standard events }
! 
!   TShiftState = public set of (ssShift, ssAlt, ssCtrl,
!     ssLeft, ssRight, ssMiddle, ssDouble);
  
  //!!!  THelpContext = -MaxLongint..MaxLongint; // not supported by Chrome
-   THelpType = public (htKeyword, htContext);
  
  //!!!  TShortCut = Low(Word)..High(Word); // not supported by Chrome
--- 218,252 ----
  { Text alignment types }
  
!   TAlignment = public (LeftJustify, RightJustify, Center);
  //!!!  TLeftRight = taLeftJustify..taRightJustify; // not supported by Chrome
!   TBiDiMode = public (LeftToRight, RightToLeft, RightToLeftNoAlign, RightToLeftReadingOnly);
!   TShiftState = public set of (Shift, Alt, Ctrl, Left, Right, Middle, Double);
!   THelpType = public (Keyword, Context);
!   
! const
!   taLeftJustify = TAlignment.LeftJustify;
!   taRightJustify = TAlignment.RightJustify;
!   taCenter = TAlignment.Center;
  
+   bdLeftToRight = TBiDiMode.LeftToRight;
+   bdRightToLeft = TBiDiMode.RightToLeft;
+   bdRightToLeftNoAlign = TBiDiMode.RightToLeftNoAlign;
+   bdRightToLeftReadingOnly = TBiDiMode.RightToLeftReadingOnly;
+   
+   ssShift = TShiftState.Shift;
+   ssAlt = TShiftState.Alt;
+   ssCtrl = TShiftState.Ctrl;
+   ssLeft = TShiftState.Left;
+   ssRight = TShiftState.Right;
+   ssMiddle = TShiftState.Middle;
+   ssDouble = TShiftState.Double;
+   
+   htKeyword = THelpType.Keyword;
+   htContext = THelpType.Context;
+   
  { Types used by standard events }
! type
  
  //!!!  THelpContext = -MaxLongint..MaxLongint; // not supported by Chrome
  
  //!!!  TShortCut = Low(Word)..High(Word); // not supported by Chrome
***************
*** 253,264 ****
  { Duplicate management }
  
!   TDuplicates = public (dupIgnore, dupAccept, dupError);
  
  { TList class }
  
    //PPointerList = public ^TPointerList;
    //TPointerList = public array[0..MaxListSize - 1] of IntPtr;
!   //TTextLineBreakStyle = public (tlbsLF, tlbsCRLF);
    
    THandle = public IntPtr;
    Currency = public Double;     // TODO: is this correct?
--- 279,301 ----
  { Duplicate management }
  
!   TDuplicates = public (Ignore, Accept, Error);
!   
! const  
!   dupIgnore = TDuplicates.Ignore;
!   dupAccept = TDuplicates.Accept;
!   dupError = TDuplicates.Error;
  
+ type
  { TList class }
  
    //PPointerList = public ^TPointerList;
    //TPointerList = public array[0..MaxListSize - 1] of IntPtr;
!   TTextLineBreakStyle = public (LF, CRLF);
!   
! const  
!   tlbsLF = TTextLineBreakStyle.LF;
!   tlbsCRLF = TTextLineBreakStyle.CRLF;
    
+ type  
    THandle = public IntPtr;
    Currency = public Double;     // TODO: is this correct?



From nobody at sheep.berlios.de  Thu May 26 16:30:18 2005
From: nobody at sheep.berlios.de (peter3)
Date: Thu, 26 May 2005 16:30:18 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL Globals.pas,NONE,1.1 Classes.pas,1.6,1.7 ShineOn.RTL.chrome,1.5,1.6 SysUtils.pas,1.6,1.7 System.pas,1.3,1.4 Types.pas,1.4,1.5
Message-ID: <200505261430.j4QEUIm04945@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv26539/ShineOn.RTL

Modified Files:
	Classes.pas ShineOn.RTL.chrome SysUtils.pas System.pas 
	Types.pas 
Added Files:
	Globals.pas 
Log Message:
- global consts and variables are now only aliases for class vars and consts in the Globals class
- new unit: Globals.pas

--- NEW FILE: Globals.pas ---
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); 
// you may not use this file except in compliance with the License. You may obtain a copy of the 
// License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF 
// ANY KIND, either express or implied. See the License for the specificlanguage governing rights and 
// limitations under the License.

// $Id: Globals.pas,v 1.1 2005/05/26 14:30:08 peter3 Exp $
namespace ShineOn.RTL;
// NOTES FOR THIS UNIT:
// This unit should only contain global variables and constants (except string constants used in messages which
// should be placed in Consts.pas).

// To add a new variable, add it as a class variable to the Globals class and then add a global variable
// pointing to the global class var. This makes the definitions useable from other languages besides Chrome.

// To add a new constant, add it as a class constant to the Globals class and then add a global constant
// pointing to the class constant. This makes the definitions useable from other languages besides Chrome.

interface
uses
  System.Windows.Forms;

type
  Globals = public class
  public
    class var ApplicationMainForm:Form := nil; // used by TThread.Synchronize();
  public
    class const MaxInt:integer = 2147483647;
    class const MaxLongint:Longint = 2147483647;
    class const MaxListSize = MaxInt div 16;
    class const soFromBeginning = 0;
    class const soFromCurrent = 1;
    class const soFromEnd = 2;
    class const soBeginning = TSeekOrigin.Beginning;
    class const soCurrent = TSeekOrigin.Current;
    class const soEnd = TSeekOrigin.End;
    class const fmCreate     = $FFFF;
    class const fmOpenRead    = $0000;
    class const fmOpenWrite   = $0001;
    class const fmOpenReadWrite = $0002;
    class const fmShareCompat  = $0000; 
    class const fmShareExclusive = $0010;
    class const fmShareDenyWrite = $0020;
    class const fmShareDenyRead = $0030; 
    class const fmShareDenyNone = $0040;
    class const toEOF   = Char(0);
    class const toSymbol = Char(1);
    class const toString = Char(2);
    class const toInteger = Char(3);
    class const toFloat  = Char(4);
    class const toWString = Char(5);
    class const scShift = $2000;
    class const scCtrl = $4000;
    class const scAlt = $8000;
    class const scNone = 0;
    class const taLeftJustify = TAlignment.LeftJustify;
    class const taRightJustify = TAlignment.RightJustify;
    class const taCenter = TAlignment.Center;
    class const bdLeftToRight = TBiDiMode.LeftToRight;
    class const bdRightToLeft = TBiDiMode.RightToLeft;
    class const bdRightToLeftNoAlign = TBiDiMode.RightToLeftNoAlign;
    class const bdRightToLeftReadingOnly = TBiDiMode.RightToLeftReadingOnly;
    class const ssShift = TShiftState.Shift;
    class const ssAlt = TShiftState.Alt;
    class const ssCtrl = TShiftState.Ctrl;
    class const ssLeft = TShiftState.Left;
    class const ssRight = TShiftState.Right;
    class const ssMiddle = TShiftState.Middle;
    class const ssDouble = TShiftState.Double;
    class const htKeyword = THelpType.Keyword;
    class const htContext = THelpType.Context;
    class const dupIgnore = TDuplicates.Ignore;
    class const dupAccept = TDuplicates.Accept;
    class const dupError = TDuplicates.Error;
    class const tlbsLF = TTextLineBreakStyle.LF;
    class const tlbsCRLF = TTextLineBreakStyle.CRLF;
    class const rfReplaceAll = TReplaceFlags.ReplaceAll;
    class const rfIgnoreCase = TReplaceFlags.IgnoreCase;
    class const lnAdded = TListNotification.Added;
    class const lnExtracted = TListNotification.Extracted;
    class const lnDeleted = TListNotification.Deleted;
    class const laCopy = TListAssignOp.Copy;
    class const laAnd = TListAssignOp.&And;
    class const laOr = TListAssignOp.&Or;
    class const laXor = TListAssignOp.&Xor;
    class const laSrcUnique = TListAssignOp.SrcUnique;
    class const laDestUnique = TListAssignOp.DestUnique;
    class const tpIdle = TThreadPriority.Idle;
    class const tpLowest = TThreadPriority.Lowest;
    class const tpLower = TThreadPriority.Lower;
    class const tpNormal = TThreadPriority.Normal;
    class const tpHigher = TThreadPriority.Higher;
    class const tpHighest = TThreadPriority.Highest;
    class const tpTimeCritical = TThreadPriority.TimeCritical;
  end;

const 
  MaxInt = Globals.MaxInt;
  MaxLongint = Globals.MaxLongint;
  MaxListSize = Globals.MaxListSize;

  soFromBeginning = Globals.soFromBeginning;
  soFromCurrent = Globals.soFromCurrent;
  soFromEnd = Globals.soFromEnd;

  soBeginning = Globals.soBeginning;
  soCurrent = Globals.soCurrent;
  soEnd = Globals.soEnd;

  { TFileStream create mode }

  fmCreate     = Globals.fmCreate;
  fmOpenRead    = Globals.fmOpenRead;
  fmOpenWrite   = Globals.fmOpenWrite;
  fmOpenReadWrite = Globals.fmOpenReadWrite;

  fmShareCompat  = Globals.fmShareCompat;
  fmShareExclusive = Globals.fmShareExclusive;
  fmShareDenyWrite = Globals.fmShareDenyWrite;
  fmShareDenyRead = Globals.fmShareDenyRead;
  fmShareDenyNone = Globals.fmShareDenyNone;


  { TParser special tokens }

  toEOF   = Globals.toEOF;
  toSymbol = Globals.toSymbol;
  toString = Globals.toString;
  toInteger = Globals.toInteger;
  toFloat  = Globals.toFloat;
  toWString = Globals.toWString;

  { TShortCut special values }

  scShift = Globals.scShift;
  scCtrl = Globals.scCtrl;
  scAlt = Globals.scAlt;
  scNone = Globals.scNone;

  taLeftJustify = Globals.taLeftJustify;
  taRightJustify = Globals.taRightJustify;
  taCenter = Globals.taCenter;

  bdLeftToRight = Globals.bdLeftToRight;
  bdRightToLeft = Globals.bdRightToLeft;
  bdRightToLeftNoAlign = Globals.bdRightToLeftNoAlign;
  bdRightToLeftReadingOnly = Globals.bdRightToLeftReadingOnly 

  ssShift = Globals.ssShift;
  ssAlt = Globals.ssAlt;
  ssCtrl = Globals.ssCtrl;
  ssLeft = Globals.ssLeft;
  ssRight = Globals.ssRight;
  ssMiddle = Globals.ssMiddle;
  ssDouble = Globals.ssDouble;

  htKeyword = Globals.htKeyword;
  htContext = Globals.htContext;

  dupIgnore = Globals.dupIgnore;
  dupAccept = Globals.dupAccept;
  dupError = Globals.dupError;

  tlbsLF = Globals.tlbsLF;
  tlbsCRLF = Globals.tlbsCRLF;

  rfReplaceAll = Globals.rfReplaceAll;
  rfIgnoreCase = Globals.rfIgnoreCase;

  lnAdded = Globals.lnAdded;
  lnExtracted = Globals.lnExtracted;
  lnDeleted = Globals.lnDeleted;

  laCopy = Globals.laCopy;
  laAnd = Globals.laAnd;
  laOr = Globals.laOr;
  laXor = Globals.laXor;
  laSrcUnique = Globals.laSrcUnique;
  laDestUnique = Globals.laDestUnique;

  tpIdle = Globals.tpIdle;
  tpLowest = Globals.tpLowest;
  tpLower = Globals.tpLower;
  tpNormal = Globals.tpNormal;
  tpHigher = Globals.tpHigher;
  tpHighest = Globals.tpHighest;
  tpTimeCritical = Globals.tpTimeCritical;
 
var
 ApplicationMainForm:Form := Globals.ApplicationMainForm;
  

implementation

end.

Index: Classes.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Classes.pas,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** Classes.pas	16 May 2005 22:05:36 -0000	1.6
--- Classes.pas	26 May 2005 14:30:08 -0000	1.7
***************
*** 22,32 ****
  uses
    System.Runtime.InteropServices, // for guid attribute
    System.Threading,
!   System.Collections;
    
  type
    TObject = public class(System.Object)
    public
!     procedure Free; { virtual? }
    end;
    
--- 22,35 ----
  uses
    System.Runtime.InteropServices, // for guid attribute
+   System.Runtime.CompilerServices,
    System.Threading,
!   System.Collections,
!   System.Windows.Forms;
    
  type
    TObject = public class(System.Object)
    public
!     procedure Free; 
!     procedure Destroy;virtual;
    end;
    
***************
*** 38,55 ****
    
    TListNotification = public (Added, Extracted, Deleted);
- const
-   lnAdded = TListNotification.Added;
-   lnExtracted = TListNotification.Extracted;
-   lnDeleted  = TListNotification.Deleted;
    
  type   
    TListAssignOp = public (Copy, &And, &Or, &Xor, SrcUnique, DestUnique);
! const  
!   laCopy = TListAssignOp.Copy;
!   laAnd = TListAssignOp.&And;
!   laOr = TListAssignOp.&Or;
!   laXor = TListAssignOp.&Xor;
!   laSrcUnique = TListAssignOp.SrcUnique;
!   laDestUnique = TListAssignOp.DestUnique;
    
  type  
--- 41,49 ----
    
    TListNotification = public (Added, Extracted, Deleted);
    
+  
  type   
    TListAssignOp = public (Copy, &And, &Or, &Xor, SrcUnique, DestUnique);
!   
    
  type  
***************
*** 280,285 ****
    end;
    
- //  TStringList = class;
- 
    TStringListSortCompare = public function(List: TStringList; Index1, Index2: Integer): Integer;
  
--- 274,277 ----
***************
*** 373,377 ****
      function Write(const Buffer:array of byte; Count: Longint): Longint; override;
      function Seek(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
!     procedure Free;reintroduce;
      property Handle: Integer read GetHandle;
    end;
--- 365,369 ----
      function Write(const Buffer:array of byte; Count: Longint): Longint; override;
      function Seek(const Offset: Int64; Origin: TSeekOrigin): Int64; override;
!     procedure Destroy;override;
      property Handle: Integer read GetHandle;
    end;
***************
*** 397,401 ****
      procedure SaveToStream(Stream: TStream);
      procedure SaveToFile(const FileName: string);
!     procedure Free;reintroduce;
      property Memory: array of byte read GetMemory;
    end;
--- 389,393 ----
      procedure SaveToStream(Stream: TStream);
      procedure SaveToFile(const FileName: string);
!     procedure Destroy;override;
      property Memory: array of byte read GetMemory;
    end;
***************
*** 494,506 ****
    TThreadPriority = public (Idle, Lowest, Lower, Normal, Higher, Highest, TimeCritical);
    
- const
-   tpIdle = TThreadPriority.Idle;
-   tpLowest = TThreadPriority.Lowest;
-   tpLower = TThreadPriority.Lower;
-   tpNormal = TThreadPriority.Normal;
-   tpHigher = TThreadPriority.Higher;
-   tpHighest = TThreadPriority.Highest;
-   tpTimeCritical = TThreadPriority.TimeCritical;
-   
  type  
    TThread = public class
--- 486,489 ----
***************
*** 521,526 ****
      procedure DoTerminate; virtual;
      procedure Execute; virtual; abstract;
      procedure Synchronize(AMethod: TThreadMethod);
!     property ReturnValue: Integer read FReturnValue write FReturnValue;
      property Terminated: Boolean read GetTerminated;
    public
--- 504,510 ----
      procedure DoTerminate; virtual;
      procedure Execute; virtual; abstract;
+     
      procedure Synchronize(AMethod: TThreadMethod);
!     property ReturnValue: Integer read FReturnValue write FReturnValue; // TODO: this is always 0 for now
      property Terminated: Boolean read GetTerminated;
    public
***************
*** 545,549 ****
  
  function RTLStreamToDotNetStream(AStream:TStream):System.IO.Stream;
! var buf:array [0..1023] of byte;ACount:integer;
  begin
    Result := new System.IO.MemoryStream;
--- 529,535 ----
  
  function RTLStreamToDotNetStream(AStream:TStream):System.IO.Stream;
! var 
!   buf:array of byte := new byte[1024]; // need to be dynamic
!   ACount:integer;
  begin
    Result := new System.IO.MemoryStream;
***************
*** 558,562 ****
  
  function DotNetStreamToRTLStream(AStream:System.IO.Stream):TStream;
! var buf:array [0..1023] of byte;ACount:integer;
  begin
    Result := new TMemoryStream;
--- 544,550 ----
  
  function DotNetStreamToRTLStream(AStream:System.IO.Stream):TStream;
! var 
!   buf:array of byte := new byte [1024];
!   ACount:integer;
  begin
    Result := new TMemoryStream;
***************
*** 570,579 ****
  end;
  
! 
! 
! procedure TObject.Free;
  begin
    if Self is IDisposable then
      IDisposable(Self).Dispose;
  end;    
  
--- 558,570 ----
  end;
  
! procedure TObject.Destroy;
  begin
    if Self is IDisposable then
      IDisposable(Self).Dispose;
+ end;
+ 
+ procedure TObject.Free;
+ begin
+   if Self <> nil then Destroy;
  end;    
  
***************
*** 1885,1889 ****
  end;
  
! procedure THandleStream.Free;
  begin
    if FStream <> nil then
--- 1876,1880 ----
  end;
  
! procedure THandleStream.Destroy;
  begin
    if FStream <> nil then
***************
*** 1894,1898 ****
      FStream := nil;
    end;
!   inherited Free;
  end;
  
--- 1885,1889 ----
      FStream := nil;
    end;
!   inherited Destroy;
  end;
  
***************
*** 2011,2018 ****
  end;
  
! procedure TCustomMemoryStream.Free;
  begin
    FStream.Close;
!   inherited Free;
  end;
  
--- 2002,2009 ----
  end;
  
! procedure TCustomMemoryStream.Destroy;
  begin
    FStream.Close;
!   inherited Destroy;
  end;
  
***************
*** 2252,2260 ****
  begin
    FThread.Abort;
  end;
  
  procedure TThread.Synchronize(AMethod: TThreadMethod);
  begin
!   NotImplemented;
  end;
  
--- 2243,2260 ----
  begin
    FThread.Abort;
+   if Assigned(FOnTerminate) then
+     FOnTerminate(Self);
  end;
  
  procedure TThread.Synchronize(AMethod: TThreadMethod);
  begin
!   with Form:Form := ApplicationMainForm do
!   begin
!     if Form = nil then
!       Form := Form.ActiveForm; // user hasn't set the global ApplicationMainForm variable, so check if there is another active form
!     if Form = nil then
!       raise EThread.Create('Cannot call TThread.Synchronize without an active form');
!     Form.Invoke(AMethod);  
!   end;
  end;
  
***************
*** 2282,2287 ****
  procedure TThread.Terminate;
  begin
!   //Synchronize(DoTerminate); // Chrome doesn't support this type of method call
!   NotImplemented;
  end;
  
--- 2282,2287 ----
  procedure TThread.Terminate;
  begin
!   FThread.Abort;
!   Synchronize(new TThreadMethod(DoTerminate));
  end;
  

Index: ShineOn.RTL.chrome
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/ShineOn.RTL.chrome,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** ShineOn.RTL.chrome	7 May 2005 10:03:31 -0000	1.5
--- ShineOn.RTL.chrome	26 May 2005 14:30:08 -0000	1.6
***************
*** 11,21 ****
      <AllowLegacyOutParams>True</AllowLegacyOutParams>
      <AllowUnsafeCode>False</AllowUnsafeCode>
      <ApplicationIcon>
      </ApplicationIcon>
    </ProjectOptions>
    <References>
!     <Reference Assembly="$(Framework)\mscorlib.dll" Display="mscorlib" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
!     <Reference Assembly="$(Framework)\System.dll" Display="System" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
!     <Reference Assembly="$(Framework)\System.Drawing.dll" Display="System.Drawing" CopyLocal="False" IgnoreStrongName="False" IgnoreVersion="False" />
    </References>
    <Configurations>
--- 11,23 ----
      <AllowLegacyOutParams>True</AllowLegacyOutParams>
      <AllowUnsafeCode>False</AllowUnsafeCode>
+     <AllowLegacyCreate>True</AllowLegacyCreate>
      <ApplicationIcon>
      </ApplicationIcon>
    </ProjectOptions>
    <References>
!     <Reference Assembly="$(Framework)\mscorlib.dll" Display="mscorlib" CopyLocal="False" />
!     <Reference Assembly="$(Framework)\System.dll" Display="System" CopyLocal="False" />
!     <Reference Assembly="$(Framework)\System.Drawing.dll" Display="System.Drawing" CopyLocal="False" />
!     <Reference Assembly="..\..\..\..\..\..\WINNT\Microsoft.NET\Framework\v1.1.4322\System.Windows.Forms.dll" Display="System.Windows.Forms.dll" CopyLocal="False" />
    </References>
    <Configurations>
***************
*** 83,86 ****
--- 85,92 ----
      </File>
      <File Filename="Types.pas">
+       <ExcludeFromBuild>False</ExcludeFromBuild>
+       <BuildAction>Compile</BuildAction>
+     </File>
+     <File Filename="Globals.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>

Index: SysUtils.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/SysUtils.pas,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** SysUtils.pas	16 May 2005 22:05:36 -0000	1.6
--- SysUtils.pas	26 May 2005 14:30:08 -0000	1.7
***************
*** 19,26 ****
    TReplaceFlags = public set of (ReplaceAll, IgnoreCase);
    
- const
-   rfReplaceAll = TReplaceFlags.ReplaceAll;
-   rfIgnoreCase = TReplaceFlags.IgnoreCase;
-   
  type
    SysUtils = public sealed class
--- 19,22 ----

Index: System.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/System.pas,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** System.pas	16 May 2005 22:05:36 -0000	1.3
--- System.pas	26 May 2005 14:30:08 -0000	1.4
***************
*** 378,382 ****
    Result := ShineOn.RTL.System.Succ(Value);
  end;
!    
  function Round(Value:Double):Integer;
  begin
--- 378,383 ----
    Result := ShineOn.RTL.System.Succ(Value);
  end;
!    
! 
  function Round(Value:Double):Integer;
  begin

Index: Types.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Types.pas,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** Types.pas	16 May 2005 22:05:36 -0000	1.4
--- Types.pas	26 May 2005 14:30:08 -0000	1.5
***************
*** 16,35 ****
    System.Runtime.InteropServices; // for guid attribute
    
- const
-   MaxInt:integer = 2147483647;
-   MaxLongint:Longint = 2147483647;
-   MaxListSize = MaxInt div 16;
- 
-   soFromBeginning = 0;
-   soFromCurrent = 1;
-   soFromEnd = 2;
  
  type
  { TStream seek origins }
    TSeekOrigin = public (Beginning, Current, &End);
- const
-   soBeginning = TSeekOrigin.Beginning;
-   soCurrent = TSeekOrigin.Current;
-   soEnd = TSeekOrigin.End;
  
  type  
--- 16,23 ----
***************
*** 182,217 ****
  
  
- 
- const
- { TFileStream create mode }
- 
-   fmCreate         = $FFFF;
-   fmOpenRead       = $0000;
-   fmOpenWrite      = $0001;
-   fmOpenReadWrite  = $0002;
- 
-   fmShareCompat    = $0000; 
-   fmShareExclusive = $0010;
-   fmShareDenyWrite = $0020;
-   fmShareDenyRead  = $0030; 
-   fmShareDenyNone  = $0040;
-   
- 
- { TParser special tokens }
- 
-   toEOF     = Char(0);
-   toSymbol  = Char(1);
-   toString  = Char(2);
-   toInteger = Char(3);
-   toFloat   = Char(4);
-   toWString = Char(5);
- 
-   { TShortCut special values }
- 
-   scShift = $2000;
-   scCtrl = $4000;
-   scAlt = $8000;
-   scNone = 0;
- 
  type
  
--- 170,173 ----
***************
*** 224,247 ****
    THelpType = public (Keyword, Context);
    
- const
-   taLeftJustify = TAlignment.LeftJustify;
-   taRightJustify = TAlignment.RightJustify;
-   taCenter = TAlignment.Center;
- 
-   bdLeftToRight = TBiDiMode.LeftToRight;
-   bdRightToLeft = TBiDiMode.RightToLeft;
-   bdRightToLeftNoAlign = TBiDiMode.RightToLeftNoAlign;
-   bdRightToLeftReadingOnly = TBiDiMode.RightToLeftReadingOnly;
-   
-   ssShift = TShiftState.Shift;
-   ssAlt = TShiftState.Alt;
-   ssCtrl = TShiftState.Ctrl;
-   ssLeft = TShiftState.Left;
-   ssRight = TShiftState.Right;
-   ssMiddle = TShiftState.Middle;
-   ssDouble = TShiftState.Double;
-   
-   htKeyword = THelpType.Keyword;
-   htContext = THelpType.Context;
    
  { Types used by standard events }
--- 180,183 ----
***************
*** 281,288 ****
    TDuplicates = public (Ignore, Accept, Error);
    
- const  
-   dupIgnore = TDuplicates.Ignore;
-   dupAccept = TDuplicates.Accept;
-   dupError = TDuplicates.Error;
  
  type
--- 217,220 ----
***************
*** 292,299 ****
    //TPointerList = public array[0..MaxListSize - 1] of IntPtr;
    TTextLineBreakStyle = public (LF, CRLF);
-   
- const  
-   tlbsLF = TTextLineBreakStyle.LF;
-   tlbsCRLF = TTextLineBreakStyle.CRLF;
    
  type  
--- 224,227 ----



From nobody at sheep.berlios.de  Fri May 27 01:40:08 2005
From: nobody at sheep.berlios.de (loonquawl)
Date: Fri, 27 May 2005 01:40:08 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL System.pas,1.4,1.5
Message-ID: <200505262340.j4QNe8m21987@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv21481/ShineOn.RTL

Modified Files:
	System.pas 
Log Message:
Implemented the Sqr and Sqrt function.

Index: System.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/System.pas,v
retrieving revision 1.4
retrieving revision 1.5
diff -C2 -d -r1.4 -r1.5
*** System.pas	26 May 2005 14:30:08 -0000	1.4
--- System.pas	26 May 2005 23:40:04 -0000	1.5
***************
*** 46,49 ****
--- 46,53 ----
      class function Frac(Value:TDateTime):Double;
      class function Odd(Value:Integer):boolean;
+     
+     class function Sqrt(Number:Extended):Extended; 
+     class function Sqr(Number:Extended):Extended; 
+     class function Sqr(Number:Integer):Integer; 
  
      // TODO: add more overloads
***************
*** 249,253 ****
  begin
    Result := Math.Exp(X);
! end;  
  
  class procedure System.SetLength(var S; Length: integer);
--- 253,272 ----
  begin
    Result := Math.Exp(X);
! end; 
! 
! class function System.Sqrt(Number:Extended): Extended; 
! begin
!   Result := Math.Sqrt(Number);
! end;
! 
! class function System.Sqr(Number:Extended): Extended; 
! begin 
!   Result := Number * Number;
! end;
! 
! class function System.Sqr(Number:Integer): Integer; 
! begin
!   Result := Number * Number;
! end; 
  
  class procedure System.SetLength(var S; Length: integer);
***************
*** 302,305 ****
--- 321,325 ----
  end;
  
+ 
  // DELPHI COMPATIBLE GLOBAL METHODS
  
***************
*** 445,448 ****
--- 465,483 ----
  end;
    
+ function Sqrt(Number:Extended): Extended; 
+ begin
+   result := ShineOn.RTL.System.Sqrt(Number);
+ end;  
+ 
+ function Sqr(Number:Extended): Extended; 
+ begin
+   result := ShineOn.RTL.System.Sqr(Number);
+ end;  
+ 
+ function Sqr(Number:Integer): Integer; 
+ begin
+   result := ShineOn.RTL.System.Sqr(Number);
+ end;  
+   
  procedure SetLength(var S; Length: integer);
  begin
***************
*** 470,474 ****
  end;
    
- 
  
  end.
--- 505,508 ----



From nobody at sheep.berlios.de  Fri May 27 01:41:30 2005
From: nobody at sheep.berlios.de (loonquawl)
Date: Fri, 27 May 2005 01:41:30 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL Globals.pas,1.1,1.2
Message-ID: <200505262341.j4QNfUm22010@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv22070/ShineOn.RTL

Modified Files:
	Globals.pas 
Log Message:
fixed a forgotten ;

Index: Globals.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Globals.pas,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** Globals.pas	26 May 2005 14:30:08 -0000	1.1
--- Globals.pas	26 May 2005 23:41:27 -0000	1.2
***************
*** 147,151 ****
    bdRightToLeft = Globals.bdRightToLeft;
    bdRightToLeftNoAlign = Globals.bdRightToLeftNoAlign;
!   bdRightToLeftReadingOnly = Globals.bdRightToLeftReadingOnly 
  
    ssShift = Globals.ssShift;
--- 147,151 ----
    bdRightToLeft = Globals.bdRightToLeft;
    bdRightToLeftNoAlign = Globals.bdRightToLeftNoAlign;
!   bdRightToLeftReadingOnly = Globals.bdRightToLeftReadingOnly; 
  
    ssShift = Globals.ssShift;



From nobody at sheep.berlios.de  Fri May 27 01:44:42 2005
From: nobody at sheep.berlios.de (peter3)
Date: Fri, 27 May 2005 01:44:42 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL Classes.pas,1.7,1.8 Contnrs.pas,1.3,1.4 Globals.pas,1.2,1.3 IniFiles.pas,1.2,1.3 SysUtils.pas,1.7,1.8 System.pas,1.5,1.6 Types.pas,1.5,1.6
Message-ID: <200505262344.j4QNigm22059@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv23719/ShineOn.RTL

Modified Files:
	Classes.pas Contnrs.pas Globals.pas IniFiles.pas SysUtils.pas 
	System.pas Types.pas 
Log Message:
- Added overloaded constructors to TThread so user can choose either a thread, control or a form to synch against
- Removed useless const parameters for strings
- Moved some missing consts to Globals

Index: Classes.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Classes.pas,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** Classes.pas	26 May 2005 14:30:08 -0000	1.7
--- Classes.pas	26 May 2005 23:44:35 -0000	1.8
***************
*** 77,81 ****
    public
      constructor Create;
!     class procedure Error(const Msg: string; Data: Integer); 
      function Add(Item: Object): Integer;
      procedure Clear; virtual;
--- 77,81 ----
    public
      constructor Create;
!     class procedure Error(Msg: string; Data: Integer); 
      function Add(Item: Object): Integer;
      procedure Clear; virtual;
***************
*** 213,222 ****
      FDelimiter, FQuoteChar:Char;
      function GetCommaText:string;
!     procedure SetCommaText(const Value:string);
      function GetName(Index:Integer):string;
!     function GetValue(const Name:string):string;
!     procedure SetValue(const Name, Value:string);
      function GetDelimitedText:string;
!     procedure SetDelimitedText(const Value:string);
      procedure SetStringsAdapter(const Value:IStringsAdapter);
    protected
--- 213,222 ----
      FDelimiter, FQuoteChar:Char;
      function GetCommaText:string;
!     procedure SetCommaText(Value:string);
      function GetName(Index:Integer):string;
!     function GetValue(Name:string):string;
!     procedure SetValue(Name, Value:string);
      function GetDelimitedText:string;
!     procedure SetDelimitedText(Value:string);
      procedure SetStringsAdapter(const Value:IStringsAdapter);
    protected
***************
*** 226,235 ****
      function GetObject(Index: Integer): Object; virtual; abstract;
      function GetTextStr: string; virtual;
!     procedure Put(Index: Integer; const S: string); virtual; abstract;
      procedure PutObject(Index: Integer; AObject: Object); virtual; abstract;
      procedure SetCapacity(NewCapacity: Integer); virtual;
!     procedure SetTextStr(const Value: string); virtual;
      property UpdateCount: Integer read FUpdateCount;
!     function CompareStrings(const S1, S2: string): Integer; virtual;
      function CompareObjects(O1, O2: Object): Integer; virtual;
      procedure Changed; virtual;
--- 226,235 ----
      function GetObject(Index: Integer): Object; virtual; abstract;
      function GetTextStr: string; virtual;
!     procedure Put(Index: Integer; S: string); virtual; abstract;
      procedure PutObject(Index: Integer; AObject: Object); virtual; abstract;
      procedure SetCapacity(NewCapacity: Integer); virtual;
!     procedure SetTextStr(Value: string); virtual;
      property UpdateCount: Integer read FUpdateCount;
!     function CompareStrings(S1, S2: string): Integer; virtual;
      function CompareObjects(O1, O2: Object): Integer; virtual;
      procedure Changed; virtual;
***************
*** 237,243 ****
    public
      constructor Create;
!     function Add(const S: string): Integer; virtual;
!     function AddObject(const S: string; AObject: Object): Integer; virtual;
!     procedure Append(const S: string);
      procedure AddStrings(Strings: TStrings); virtual;
      procedure Assign(Source: TPersistent); override;
--- 237,243 ----
    public
      constructor Create;
!     function Add(S: string): Integer; virtual;
!     function AddObject(S: string; AObject: Object): Integer; virtual;
!     procedure Append(S: string);
      procedure AddStrings(Strings: TStrings); virtual;
      procedure Assign(Source: TPersistent); override;
***************
*** 249,263 ****
      procedure Exchange(Index1, Index2: Integer); virtual;
      function GetText: String; virtual;
!     function IndexOf(const S: string): Integer; virtual;
!     function IndexOfName(const Name: string): Integer; virtual;
      function IndexOfObject(AObject: Object): Integer; virtual;
!     procedure Insert(Index: Integer; const S: string); virtual; abstract;
!     procedure InsertObject(Index: Integer; const S: string; AObject: Object); virtual;
!     procedure LoadFromFile(const FileName: string); virtual;
      procedure LoadFromStream(Stream: TStream); virtual;
      procedure Move(CurIndex, NewIndex: Integer); virtual;
!     procedure SaveToFile(const FileName: string); virtual;
      procedure SaveToStream(Stream: TStream); virtual;
!     procedure SetText(const Text: String); virtual;
      property Capacity: Integer read GetCapacity write SetCapacity;
      property CommaText: string read GetCommaText write SetCommaText;
--- 249,263 ----
      procedure Exchange(Index1, Index2: Integer); virtual;
      function GetText: String; virtual;
!     function IndexOf(S: string): Integer; virtual;
!     function IndexOfName(Name: string): Integer; virtual;
      function IndexOfObject(AObject: Object): Integer; virtual;
!     procedure Insert(Index: Integer; S: string); virtual; abstract;
!     procedure InsertObject(Index: Integer; S: string; AObject: Object); virtual;
!     procedure LoadFromFile(FileName: string); virtual;
      procedure LoadFromStream(Stream: TStream); virtual;
      procedure Move(CurIndex, NewIndex: Integer); virtual;
!     procedure SaveToFile(FileName: string); virtual;
      procedure SaveToStream(Stream: TStream); virtual;
!     procedure SetText(Text: String); virtual;
      property Capacity: Integer read GetCapacity write SetCapacity;
      property CommaText: string read GetCommaText write SetCommaText;
***************
*** 287,291 ****
      function GetCount: Integer; override;
      function GetObject(Index: Integer): Object; override;
!     procedure Put(Index: Integer; const S: string); override;
      procedure PutObject(Index: Integer; AObject: Object); override;
      procedure SetCapacity(NewCapacity: Integer); override;
--- 287,291 ----
      function GetCount: Integer; override;
      function GetObject(Index: Integer): Object; override;
!     procedure Put(Index: Integer; S: string); override;
      procedure PutObject(Index: Integer; AObject: Object); override;
      procedure SetCapacity(NewCapacity: Integer); override;
***************
*** 296,308 ****
    public
      constructor Create;
!     function CompareStrings(const S1, S2: string): Integer; override;
      // destructor Destroy;override;
      procedure Clear; override;
      procedure Delete(Index: Integer); override;
      procedure Exchange(Index1, Index2: Integer); override;
!     function Find(const S: string; var Index: Integer): Boolean; virtual;
!     function IndexOf(const S: string): Integer; override;
!     procedure InsertObject(Index: Integer; const S: string; AObject: Object); override;
!     procedure Insert(Index: Integer; const S: string);override;
      procedure Sort; virtual;
      procedure CustomSort(Compare: TStringListSortCompare); virtual;
--- 296,308 ----
    public
      constructor Create;
!     function CompareStrings(S1, S2: string): Integer; override;
      // destructor Destroy;override;
      procedure Clear; override;
      procedure Delete(Index: Integer); override;
      procedure Exchange(Index1, Index2: Integer); override;
!     function Find(S: string; var Index: Integer): Boolean; virtual;
!     function IndexOf(S: string): Integer; override;
!     procedure InsertObject(Index: Integer; S: string; AObject: Object); override;
!     procedure Insert(Index: Integer; S: string);override;
      procedure Sort; virtual;
      procedure CustomSort(Compare: TStringListSortCompare); virtual;
***************
*** 321,325 ****
    assembly or protected
      function ReadLine:string;virtual;abstract;
!     procedure WriteLine(const Value:string);virtual;abstract;
    protected
      procedure SetSize(const NewSize: Int64); virtual;abstract;
--- 321,325 ----
    assembly or protected
      function ReadLine:string;virtual;abstract;
!     procedure WriteLine(Value:string);virtual;abstract;
    protected
      procedure SetSize(const NewSize: Int64); virtual;abstract;
***************
*** 335,342 ****
      function ReadComponentRes(Instance: TComponent): TComponent;
      procedure WriteComponent(Instance: TComponent);
!     procedure WriteComponentRes(const ResName: string; Instance: TComponent);
      procedure WriteDescendent(Instance, Ancestor: TComponent); 
!     procedure WriteDescendentRes(const ResName: string; Instance, Ancestor: TComponent);
!     procedure WriteResourceHeader(const ResName: string; out FixupInfo: Integer);
      procedure FixupResourceHeader(FixupInfo: Integer);
      procedure ReadResHeader;
--- 335,342 ----
      function ReadComponentRes(Instance: TComponent): TComponent;
      procedure WriteComponent(Instance: TComponent);
!     procedure WriteComponentRes(ResName: string; Instance: TComponent);
      procedure WriteDescendent(Instance, Ancestor: TComponent); 
!     procedure WriteDescendentRes(ResName: string; Instance, Ancestor: TComponent);
!     procedure WriteResourceHeader(ResName: string; out FixupInfo: Integer);
      procedure FixupResourceHeader(FixupInfo: Integer);
      procedure ReadResHeader;
***************
*** 359,363 ****
    assembly or protected
      function ReadLine:string;override;
!     procedure WriteLine(const Value:string);override;
    public
      constructor Create(AHandle: Integer);
--- 359,363 ----
    assembly or protected
      function ReadLine:string;override;
!     procedure WriteLine(Value:string);override;
    public
      constructor Create(AHandle: Integer);
***************
*** 371,376 ****
    TFileStream = public class(THandleStream)
    public
!     constructor Create(const FileName: string; Mode: Word); 
!     constructor Create(const FileName: string; Mode: Word; Rights: Cardinal); 
    end;
    
--- 371,376 ----
    TFileStream = public class(THandleStream)
    public
!     constructor Create(FileName: string; Mode: Word); 
!     constructor Create(FileName: string; Mode: Word; Rights: Cardinal); 
    end;
    
***************
*** 388,392 ****
      function Seek(Offset: Int64; Origin: TSeekOrigin): Int64; override;
      procedure SaveToStream(Stream: TStream);
!     procedure SaveToFile(const FileName: string);
      procedure Destroy;override;
      property Memory: array of byte read GetMemory;
--- 388,392 ----
      function Seek(Offset: Int64; Origin: TSeekOrigin): Int64; override;
      procedure SaveToStream(Stream: TStream);
!     procedure SaveToFile(FileName: string);
      procedure Destroy;override;
      property Memory: array of byte read GetMemory;
***************
*** 401,409 ****
      property Capacity: Longint read GetCapacity write SetCapacity;
    assembly or protected
!     procedure WriteLine(const Value:string);override;
    public
      procedure Clear;
      procedure LoadFromStream(Stream: TStream);
!     procedure LoadFromFile(const FileName: string);
      function Write(const Buffer:array of byte; Count: Longint): Longint; override;
    end;
--- 401,409 ----
      property Capacity: Longint read GetCapacity write SetCapacity;
    assembly or protected
!     procedure WriteLine(Value:string);override;
    public
      procedure Clear;
      procedure LoadFromStream(Stream: TStream);
!     procedure LoadFromFile(FileName: string);
      function Write(const Buffer:array of byte; Count: Longint): Longint; override;
    end;
***************
*** 418,429 ****
    assembly or protected
      function ReadLine:string;override;
!     procedure WriteLine(const Value:string);override;
    public
!     constructor Create(const AString: string);
      function Read(var Buffer:array of byte; Count: Longint): Longint; override;
      function ReadString(Count: Longint): string;
      function Seek(Offset: Int64; Origin: TSeekOrigin): Int64; override;
      function Write(const Buffer:array of byte; Count: Longint): Longint; override;
!     procedure WriteString(const AString: string);
      property DataString: string read GetDataString;
    end;
--- 418,429 ----
    assembly or protected
      function ReadLine:string;override;
!     procedure WriteLine(Value:string);override;
    public
!     constructor Create(AString: string);
      function Read(var Buffer:array of byte; Count: Longint): Longint; override;
      function ReadString(Count: Longint): string;
      function Seek(Offset: Int64; Origin: TSeekOrigin): Int64; override;
      function Write(const Buffer:array of byte; Count: Longint): Longint; override;
!     procedure WriteString(AString: string);
      property DataString: string read GetDataString;
    end;
***************
*** 436,442 ****
    assembly or protected
      function ReadLine:string;override;
!     procedure WriteLine(const Value:string);override;
    public
!     constructor Create(Instance: THandle; const ResName: string; ResType: String);
      // chrome doesn't support constructors not named "Create"
      class function CreateFromID(Instance: THandle; ResID: Integer; ResType: String):TResourceStream;
--- 436,442 ----
    assembly or protected
      function ReadLine:string;override;
!     procedure WriteLine(Value:string);override;
    public
!     constructor Create(Instance: THandle; ResName: string; ResType: String);
      // chrome doesn't support constructors not named "Create"
      class function CreateFromID(Instance: THandle; ResID: Integer; ResType: String):TResourceStream;
***************
*** 483,486 ****
--- 483,487 ----
  
    TThreadMethod = public procedure of object;
+   TThreadMethodWithArgs = public procedure (Args:array of Object) of object;
  
    TThreadPriority = public (Idle, Lowest, Lower, Normal, Higher, Highest, TimeCritical);
***************
*** 489,493 ****
    TThread = public class
    private
!     FThread:Thread;
      FReturnValue:Integer;
      FFatalException:Object;
--- 490,496 ----
    TThread = public class
    private
!     FThread, FSynchThread:Thread;
!     FSynchForm:Form;
!     FSynchControl:Control;
      FReturnValue:Integer;
      FFatalException:Object;
***************
*** 510,513 ****
--- 513,520 ----
    public
      constructor Create(CreateSuspended: Boolean);
+     constructor Create(CreateSuspended: Boolean; SynchThread:Thread);
+     constructor Create(CreateSuspended: Boolean; SynchControl:Control);
+     constructor Create(CreateSuspended: Boolean; SynchForm:Form);
+     
      procedure Resume;
      procedure Suspend;
***************
*** 528,531 ****
--- 535,539 ----
  implementation
  
+ 
  function RTLStreamToDotNetStream(AStream:TStream):System.IO.Stream;
  var 
***************
*** 566,570 ****
  procedure TObject.Free;
  begin
!   if Self <> nil then Destroy;
  end;    
  
--- 574,579 ----
  procedure TObject.Free;
  begin
!   if Self <> nil then 
!     Destroy;
  end;    
  
***************
*** 595,599 ****
  
  function TStringlistSortCompareWrapper.Compare(X,Y:Object):Integer;
!   function FindItem(const S:String):Integer;
    begin
      for Result := 0 to FStrings.Count - 1 do
--- 604,608 ----
  
  function TStringlistSortCompareWrapper.Compare(X,Y:Object):Integer;
!   function FindItem(S:String):Integer;
    begin
      for Result := 0 to FStrings.Count - 1 do
***************
*** 629,633 ****
  end;
  
! procedure TList.SetCapacity(const Value:integer);
  begin
    FList.Capacity := Value;
--- 638,642 ----
  end;
  
! procedure TList.SetCapacity(Value:integer);
  begin
    FList.Capacity := Value;
***************
*** 639,643 ****
  end;
  
! procedure TList.SetCount(const Value:integer);
  var
    I: Integer;
--- 648,652 ----
  end;
  
! procedure TList.SetCount(Value:integer);
  var
    I: Integer;
***************
*** 662,666 ****
  end;
  
! procedure TList.Put(Index:integer; const Value:Object);
  var Temp:Object;
  begin
--- 671,675 ----
  end;
  
! procedure TList.Put(Index:integer; Value:Object);
  var Temp:Object;
  begin
***************
*** 689,693 ****
  end;
  
! class procedure TList.Error(const Msg: string; Data: Integer); 
  begin
    raise EListError.Create(string.Format(Msg, Data));
--- 698,702 ----
  end;
  
! class procedure TList.Error(Msg: string; Data: Integer); 
  begin
    raise EListError.Create(string.Format(Msg, Data));
***************
*** 1227,1231 ****
  end;
  
! procedure TStrings.SetCommaText(const Value:string);
  var ASep, AQuote:Char;
  begin
--- 1236,1240 ----
  end;
  
! procedure TStrings.SetCommaText(Value:string);
  var ASep, AQuote:Char;
  begin
***************
*** 1253,1257 ****
  end;
  
! function TStrings.GetValue(const Name:string):string;
  var i:integer;
  begin
--- 1262,1266 ----
  end;
  
! function TStrings.GetValue(Name:string):string;
  var i:integer;
  begin
***************
*** 1263,1267 ****
  end;
  
! procedure TStrings.SetValue(const Name, Value:string);
  var i:integer;
  begin
--- 1272,1276 ----
  end;
  
! procedure TStrings.SetValue(Name, Value:string);
  var i:integer;
  begin
***************
*** 1293,1297 ****
  end;
  
! procedure TStrings.SetDelimitedText(const Value:string);
  begin
    Clear;
--- 1302,1306 ----
  end;
  
! procedure TStrings.SetDelimitedText(Value:string);
  begin
    Clear;
***************
*** 1335,1339 ****
  end;
  
! procedure TStrings.SetTextStr(const Value: string); 
  var S:String;
  begin
--- 1344,1348 ----
  end;
  
! procedure TStrings.SetTextStr(Value: string); 
  var S:String;
  begin
***************
*** 1352,1356 ****
  end;
  
! function TStrings.CompareStrings(const S1, S2: string): Integer; 
  begin
    Result := AnsiCompareText(S1, S2);
--- 1361,1365 ----
  end;
  
! function TStrings.CompareStrings(S1, S2: string): Integer; 
  begin
    Result := AnsiCompareText(S1, S2);
***************
*** 1377,1386 ****
  end;
  
! function TStrings.Add(const S: string): Integer; 
  begin
    Result := AddObject(S, nil);
  end;
  
! function TStrings.AddObject(const S: string; AObject: Object): Integer; 
  begin
    Result := Count;
--- 1386,1395 ----
  end;
  
! function TStrings.Add(S: string): Integer; 
  begin
    Result := AddObject(S, nil);
  end;
  
! function TStrings.AddObject(S: string; AObject: Object): Integer; 
  begin
    Result := Count;
***************
*** 1388,1392 ****
  end;
  
! procedure TStrings.Append(const S: string);
  begin
    Add(S);
--- 1397,1401 ----
  end;
  
! procedure TStrings.Append(S: string);
  begin
    Add(S);
***************
*** 1466,1475 ****
  end;
  
! procedure TStrings.SetText(const Text: String); 
  begin
    SetTextStr(Text);
  end;
  
! function TStrings.IndexOf(const S: string): Integer; 
  begin
    for Result := 0 to Count -1 do
--- 1475,1484 ----
  end;
  
! procedure TStrings.SetText(Text: String); 
  begin
    SetTextStr(Text);
  end;
  
! function TStrings.IndexOf(S: string): Integer; 
  begin
    for Result := 0 to Count -1 do
***************
*** 1479,1483 ****
  end;
  
! function TStrings.IndexOfName(const Name: string): Integer; 
  var 
    AName:string;
--- 1488,1492 ----
  end;
  
! function TStrings.IndexOfName(Name: string): Integer; 
  var 
    AName:string;
***************
*** 1505,1509 ****
  end;
  
! procedure TStrings.InsertObject(Index: Integer; const S: string; AObject: Object); 
  begin
    Insert(Index, S);
--- 1514,1518 ----
  end;
  
! procedure TStrings.InsertObject(Index: Integer; S: string; AObject: Object); 
  begin
    Insert(Index, S);
***************
*** 1511,1515 ****
  end;
  
! procedure TStrings.LoadFromFile(const FileName: string); 
  var F:TFileStream;
  begin
--- 1520,1524 ----
  end;
  
! procedure TStrings.LoadFromFile(FileName: string); 
  var F:TFileStream;
  begin
***************
*** 1546,1550 ****
  end;
  
! procedure TStrings.SaveToFile(const FileName: string); 
  var F:TFileStream;
  begin
--- 1555,1559 ----
  end;
  
! procedure TStrings.SaveToFile(FileName: string); 
  var F:TFileStream;
  begin
***************
*** 1592,1596 ****
  end;
  
! procedure TStringlist.Put(Index: Integer; const S: string); 
  begin
    if CompareStrings(TStringItem(FStrings[Index]).AString,S) <> 0 then
--- 1601,1605 ----
  end;
  
! procedure TStringlist.Put(Index: Integer; S: string); 
  begin
    if CompareStrings(TStringItem(FStrings[Index]).AString,S) <> 0 then
***************
*** 1617,1621 ****
  end;
  
! function TStringlist.CompareStrings(const S1, S2: string): Integer; 
  begin
    if CaseSensitive then
--- 1626,1630 ----
  end;
  
! function TStringlist.CompareStrings(S1, S2: string): Integer; 
  begin
    if CaseSensitive then
***************
*** 1682,1686 ****
  end;
  
! function TStringlist.Find(const S: string; var Index: Integer): Boolean; 
  begin
    //TODO: implement binary search once sorting is implemented;
--- 1691,1695 ----
  end;
  
! function TStringlist.Find(S: string; var Index: Integer): Boolean; 
  begin
    //TODO: implement binary search once sorting is implemented;
***************
*** 1693,1697 ****
  end;
  
! function TStringlist.IndexOf(const S: string): Integer; 
  begin
    if not Sorted then 
--- 1702,1706 ----
  end;
  
! function TStringlist.IndexOf(S: string): Integer; 
  begin
    if not Sorted then 
***************
*** 1702,1711 ****
  end;
  
! procedure TStringlist.Insert(Index: Integer; const S: string); 
  begin
    InsertObject(Index, S, nil);
  end;
  
! procedure TStringlist.InsertObject(Index: Integer; const S: string; AObject: Object); 
  var AItem:TStringItem;
  begin
--- 1711,1720 ----
  end;
  
! procedure TStringlist.Insert(Index: Integer; S: string); 
  begin
    InsertObject(Index, S, nil);
  end;
  
! procedure TStringlist.InsertObject(Index: Integer; S: string; AObject: Object); 
  var AItem:TStringItem;
  begin
***************
*** 1807,1811 ****
  end;
  
! procedure TStream.WriteComponentRes(const ResName: string; Instance: TComponent);
  begin
    NotImplemented;
--- 1816,1820 ----
  end;
  
! procedure TStream.WriteComponentRes(ResName: string; Instance: TComponent);
  begin
    NotImplemented;
***************
*** 1817,1826 ****
  end;
  
! procedure TStream.WriteDescendentRes(const ResName: string; Instance, Ancestor: TComponent);
  begin
    NotImplemented;
  end;
  
! procedure TStream.WriteResourceHeader(const ResName: string; out FixupInfo: Integer);
  begin
    NotImplemented;
--- 1826,1835 ----
  end;
  
! procedure TStream.WriteDescendentRes(ResName: string; Instance, Ancestor: TComponent);
  begin
    NotImplemented;
  end;
  
! procedure TStream.WriteResourceHeader(ResName: string; out FixupInfo: Integer);
  begin
    NotImplemented;
***************
*** 1844,1848 ****
  end;
  
! procedure THandleStream.SetSize(const NewSize: Int64); 
  begin
    FStream.SetLength(NewSize);
--- 1853,1857 ----
  end;
  
! procedure THandleStream.SetSize(NewSize: Int64); 
  begin
    FStream.SetLength(NewSize);
***************
*** 1894,1898 ****
  end;
  
! procedure THandleStream.WriteLine(const Value:string); 
  begin
    with T:System.IO.StreamWriter := System.IO.StreamWriter(FStream) do
--- 1903,1907 ----
  end;
  
! procedure THandleStream.WriteLine(Value:string); 
  begin
    with T:System.IO.StreamWriter := System.IO.StreamWriter(FStream) do
***************
*** 1903,1907 ****
  { TFileStream }
  
! constructor TFileStream.Create(const FileName: string; Mode: Word); 
  begin
    Create(Filename , Mode, 0);
--- 1912,1916 ----
  { TFileStream }
  
! constructor TFileStream.Create(FileName: string; Mode: Word); 
  begin
    Create(Filename , Mode, 0);
***************
*** 1909,1913 ****
  
  
! constructor TFileStream.Create(const FileName: string; Mode: Word; Rights: Cardinal); 
  var 
    FileMode:System.IO.FileMode;
--- 1918,1922 ----
  
  
! constructor TFileStream.Create(FileName: string; Mode: Word; Rights: Cardinal); 
  var 
    FileMode:System.IO.FileMode;
***************
*** 1986,1990 ****
  end;
  
! procedure TCustomMemoryStream.SaveToFile(const FileName: string);
  var F:TFileStream;
  begin
--- 1995,1999 ----
  end;
  
! procedure TCustomMemoryStream.SaveToFile(FileName: string);
  var F:TFileStream;
  begin
***************
*** 2026,2030 ****
  end;
  
! procedure TMemoryStream.WriteLine(const Value:string);
  begin
    with T:System.IO.StreamWriter := System.IO.StreamWriter(FStream) do
--- 2035,2039 ----
  end;
  
! procedure TMemoryStream.WriteLine(Value:string);
  begin
    with T:System.IO.StreamWriter := System.IO.StreamWriter(FStream) do
***************
*** 2043,2047 ****
  end;
  
! procedure TMemoryStream.LoadFromFile(const FileName: string);
  var f:TFIleStream;
  begin
--- 2052,2056 ----
  end;
  
! procedure TMemoryStream.LoadFromFile(FileName: string);
  var f:TFIleStream;
  begin
***************
*** 2075,2079 ****
  end;
  
! constructor TStringStream.Create(const AString: string);
  begin
    inherited Create;
--- 2084,2088 ----
  end;
  
! constructor TStringStream.Create(AString: string);
  begin
    inherited Create;
***************
*** 2121,2125 ****
  end;
  
! procedure TStringStream.WriteString(const AString: string);
  begin
    if AString <> '' then
--- 2130,2134 ----
  end;
  
! procedure TStringStream.WriteString(AString: string);
  begin
    if AString <> '' then
***************
*** 2142,2146 ****
  end;
  
! procedure TStringStream.WriteLine(const Value:string); 
  begin
    WriteString(Value);
--- 2151,2155 ----
  end;
  
! procedure TStringStream.WriteLine(Value:string); 
  begin
    WriteString(Value);
***************
*** 2149,2153 ****
  { TResourceStream }
  
! constructor TResourceStream.Create(Instance: THandle; const ResName: string; ResType: String);
  begin
    inherited Create;
--- 2158,2162 ----
  { TResourceStream }
  
! constructor TResourceStream.Create(Instance: THandle; ResName: string; ResType: String);
  begin
    inherited Create;
***************
*** 2179,2183 ****
  end;
  
! procedure TResourceStream.WriteLine(const Value:string); 
  begin
    raise EStreamError.Create(SCantWriteResourceStreamError);
--- 2188,2192 ----
  end;
  
! procedure TResourceStream.WriteLine(Value:string); 
  begin
    raise EStreamError.Create(SCantWriteResourceStreamError);
***************
*** 2249,2262 ****
  procedure TThread.Synchronize(AMethod: TThreadMethod);
  begin
!   with Form:Form := ApplicationMainForm do
    begin
!     if Form = nil then
!       Form := Form.ActiveForm; // user hasn't set the global ApplicationMainForm variable, so check if there is another active form
!     if Form = nil then
!       raise EThread.Create('Cannot call TThread.Synchronize without an active form');
!     Form.Invoke(AMethod);  
!   end;
  end;
  
  constructor TThread.Create(CreateSuspended: Boolean);
  begin
--- 2258,2282 ----
  procedure TThread.Synchronize(AMethod: TThreadMethod);
  begin
!   if FThread <> nil then
    begin
!     FThread.Join();
!     AMethod();
!   end
!   else if FSynchControl <> nil then
!     FSynchControl.Invoke(AMethod)
!   else if FSynchForm <> nil then
!     FSynchForm.Invoke(AMethod)
!   else 
!     with Form:Form := ApplicationMainForm do
!     begin
!       if Form = nil then
!         Form := Form.ActiveForm; // user hasn't set the global ApplicationMainForm variable, so check if there is another active form
!       if Form = nil then
!        raise EThread.Create('Cannot call TThread.Synchronize without an active form, control or thread');
!       Form.Invoke(AMethod);  
!     end;
  end;
  
+ 
  constructor TThread.Create(CreateSuspended: Boolean);
  begin
***************
*** 2265,2268 ****
--- 2285,2306 ----
    if not CreateSuspended then
      FThread.Start;
+ end;
+ 
+ constructor TThread.Create(CreateSuspended: Boolean; SynchThread:Thread);
+ begin
+   Create(CreateSuspended);
+   FSynchThread := SynchThread;
+ end;
+ 
+ constructor TThread.Create(CreateSuspended: Boolean; SynchControl:Control);
+ begin
+   Create(CreateSuspended);
+   FSynchControl := SynchControl;
+ end;
+ 
+ constructor TThread.Create(CreateSuspended: Boolean; SynchForm:Form);
+ begin
+   Create(CreateSuspended);
+   FSynchForm := SynchForm;
  end;
  

Index: Contnrs.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Contnrs.pas,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** Contnrs.pas	16 May 2005 22:05:36 -0000	1.3
--- Contnrs.pas	26 May 2005 23:44:35 -0000	1.4
***************
*** 154,166 ****
    TBucketListSizes = public (BucketSize2, BucketSize4, BucketSize8, BucketSize16, BucketSize32, BucketSize64, BucketSize128, BucketSize256);
    
- const  
-   bl2 = TBucketListSizes.BucketSize2;
-   bl4 = TBucketListSizes.BucketSize4;
-   bl8 = TBucketListSizes.BucketSize8;
-   bl16 = TBucketListSizes.BucketSize16;
-   bl32 = TBucketListSizes.BucketSize32;
-   bl64 = TBucketListSizes.BucketSize64;
-   bl128 = TBucketListSizes.BucketSize128;
-   bl256 = TBucketListSizes.BucketSize256;
    
  type
--- 154,157 ----

Index: Globals.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Globals.pas,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** Globals.pas	26 May 2005 23:41:27 -0000	1.2
--- Globals.pas	26 May 2005 23:44:35 -0000	1.3
***************
*** 95,98 ****
--- 95,106 ----
      class const tpHighest = TThreadPriority.Highest;
      class const tpTimeCritical = TThreadPriority.TimeCritical;
+     class const bl2 = TBucketListSizes.BucketSize2;
+     class const bl4 = TBucketListSizes.BucketSize4;
+     class const bl8 = TBucketListSizes.BucketSize8;
+     class const bl16 = TBucketListSizes.BucketSize16;
+     class const bl32 = TBucketListSizes.BucketSize32;
+     class const bl64 = TBucketListSizes.BucketSize64;
+     class const bl128 = TBucketListSizes.BucketSize128;
+     class const bl256 = TBucketListSizes.BucketSize256;
    end;
  
***************
*** 188,191 ****
--- 196,208 ----
    tpHighest = Globals.tpHighest;
    tpTimeCritical = Globals.tpTimeCritical;
+ 
+   bl2 = Globals.bl2;
+   bl4 = Globals.bl4;
+   bl8 = Globals.bl8;
+   bl16 = Globals.bl16;
+   bl32 = Globals.bl32;
+   bl64 = Globals.bl64;
+   bl128 = Globals.bl128;
+   bl256 = Globals.bl256;
   
  var

Index: IniFiles.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/IniFiles.pas,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** IniFiles.pas	25 Apr 2005 17:51:44 -0000	1.2
--- IniFiles.pas	26 May 2005 23:44:35 -0000	1.3
***************
*** 20,48 ****
      FFileName: string;
    public
!     constructor Create(const FileName: string);
!     function SectionExists(const Section: string): Boolean;
!     function ReadString(const Section, Name, Default: string): string; virtual; abstract;
!     procedure WriteString(const Section, Name, Value: String); virtual; abstract;
!     function ReadInteger(const Section, Name: string; Default: Longint): Longint; virtual;
!     procedure WriteInteger(const Section, Name: string; Value: Longint); virtual;
!     function ReadBool(const Section, Name: string; Default: Boolean): Boolean; virtual;
!     procedure WriteBool(const Section, Name: string; Value: Boolean); virtual;
!     function ReadBinaryStream(const Section, Name: string; Value: TStream): Integer; virtual;
!     function ReadDate(const Section, Name: string; Default: TDateTime): TDateTime; virtual;
!     function ReadDateTime(const Section, Name: string; Default: TDateTime): TDateTime; virtual;
!     function ReadFloat(const Section, Name: string; Default: Double): Double; virtual;
!     function ReadTime(const Section, Name: string; Default: TDateTime): TDateTime; virtual;
!     procedure WriteBinaryStream(const Section, Name: string; Value: TStream); virtual;
!     procedure WriteDate(const Section, Name: string; Value: TDateTime); virtual;
!     procedure WriteDateTime(const Section, Name: string; Value: TDateTime); virtual;
!     procedure WriteFloat(const Section, Name: string; Value: Double); virtual;
!     procedure WriteTime(const Section, Name: string; Value: TDateTime); virtual;
!     procedure ReadSection(const Section: string; Strings: TStrings); virtual; abstract;
      procedure ReadSections(Strings: TStrings); virtual; abstract;
!     procedure ReadSectionValues(const Section: string; Strings: TStrings); virtual; abstract;
!     procedure EraseSection(const Section: string); virtual; abstract;
!     procedure DeleteKey(const Section, Name: String); virtual; abstract;
      procedure UpdateFile; virtual; abstract;
!     function ValueExists(const Section, Name: string): Boolean;
      property FileName: string read FFileName;
    end;
--- 20,48 ----
      FFileName: string;
    public
!     constructor Create(FileName: string);
!     function SectionExists(Section: string): Boolean;
!     function ReadString(Section, Name, Default: string): string; virtual; abstract;
!     procedure WriteString(Section, Name, Value: String); virtual; abstract;
!     function ReadInteger(Section, Name: string; Default: Longint): Longint; virtual;
!     procedure WriteInteger(Section, Name: string; Value: Longint); virtual;
!     function ReadBool(Section, Name: string; Default: Boolean): Boolean; virtual;
!     procedure WriteBool(Section, Name: string; Value: Boolean); virtual;
!     function ReadBinaryStream(Section, Name: string; Value: TStream): Integer; virtual;
!     function ReadDate(Section, Name: string; Default: TDateTime): TDateTime; virtual;
!     function ReadDateTime(Section, Name: string; Default: TDateTime): TDateTime; virtual;
!     function ReadFloat(Section, Name: string; Default: Double): Double; virtual;
!     function ReadTime(Section, Name: string; Default: TDateTime): TDateTime; virtual;
!     procedure WriteBinaryStream(Section, Name: string; Value: TStream); virtual;
!     procedure WriteDate(Section, Name: string; Value: TDateTime); virtual;
!     procedure WriteDateTime(Section, Name: string; Value: TDateTime); virtual;
!     procedure WriteFloat(Section, Name: string; Value: Double); virtual;
!     procedure WriteTime(Section, Name: string; Value: TDateTime); virtual;
!     procedure ReadSection(Section: string; Strings: TStrings); virtual; abstract;
      procedure ReadSections(Strings: TStrings); virtual; abstract;
!     procedure ReadSectionValues(Section: string; Strings: TStrings); virtual; abstract;
!     procedure EraseSection(Section: string); virtual; abstract;
!     procedure DeleteKey(Section, Name: String); virtual; abstract;
      procedure UpdateFile; virtual; abstract;
!     function ValueExists(Section, Name: string): Boolean;
      property FileName: string read FFileName;
    end;
***************
*** 55,75 ****
    private
      FSections: TStringList;
!     function AddSection(const Section: string): TStrings;
      procedure LoadValues;
    public
!     constructor Create(const FileName: string);
      procedure Free;reintroduce;
      procedure Clear;
!     procedure DeleteKey(const Section, Name: String); override;
!     procedure EraseSection(const Section: string); override;
      procedure GetStrings(List: TStrings);
!     procedure ReadSection(const Section: string; Strings: TStrings); override;
      procedure ReadSections(Strings: TStrings); override;
!     procedure ReadSectionValues(const Section: string; Strings: TStrings); override;
!     function ReadString(const Section, Name, Default: string): string; override;
!     procedure Rename(const FileName: string; Reload: Boolean);
      procedure SetStrings(List: TStrings);
      procedure UpdateFile; override;
!     procedure WriteString(const Section, Name, Value: String); override;
    end;
    
--- 55,75 ----
    private
      FSections: TStringList;
!     function AddSection(Section: string): TStrings;
      procedure LoadValues;
    public
!     constructor Create(FileName: string);
      procedure Free;reintroduce;
      procedure Clear;
!     procedure DeleteKey(Section, Name: String); override;
!     procedure EraseSection(Section: string); override;
      procedure GetStrings(List: TStrings);
!     procedure ReadSection(Section: string; Strings: TStrings); override;
      procedure ReadSections(Strings: TStrings); override;
!     procedure ReadSectionValues(Section: string; Strings: TStrings); override;
!     function ReadString(Section, Name, Default: string): string; override;
!     procedure Rename(FileName: string; Reload: Boolean);
      procedure SetStrings(List: TStrings);
      procedure UpdateFile; override;
!     procedure WriteString(Section, Name, Value: String); override;
    end;
    
***************
*** 80,84 ****
  
  { TCustomIniFile }
! constructor TCustomIniFile.Create(const FileName: string); 
  begin
    inherited Create;
--- 80,84 ----
  
  { TCustomIniFile }
! constructor TCustomIniFile.Create(FileName: string); 
  begin
    inherited Create;
***************
*** 86,90 ****
  end;
  
! function TCustomIniFile.SectionExists(const Section: string): Boolean; 
  var S:TStringlist;
  begin
--- 86,90 ----
  end;
  
! function TCustomIniFile.SectionExists(Section: string): Boolean; 
  var S:TStringlist;
  begin
***************
*** 94,98 ****
  end;
  
! function TCustomIniFile.ReadInteger(const Section, Name: string; Default: Longint): Longint; 
  var S:string;
  begin
--- 94,98 ----
  end;
  
! function TCustomIniFile.ReadInteger(Section, Name: string; Default: Longint): Longint; 
  var S:string;
  begin
***************
*** 103,127 ****
  end;
  
! procedure TCustomIniFile.WriteInteger(const Section, Name: string; Value: Longint); 
  begin
    WriteString(Section, Name, Value.ToString);
  end;
  
! function TCustomIniFile.ReadBool(const Section, Name: string; Default: Boolean): Boolean; 
  begin
    Result := ReadInteger(Section, Name, Ord(Default)) <> 0;
  end;
  
! procedure TCustomIniFile.WriteBool(const Section, Name: string; Value: Boolean); 
  begin
    WriteInteger(Section, Name, Ord(Value));
  end;
  
! function TCustomIniFile.ReadBinaryStream(const Section, Name: string; Value: TStream): Integer; 
  begin
    NotImplemented;
  end;
  
! function TCustomIniFile.ReadDate(const Section, Name: string; Default: TDateTime): TDateTime; 
  begin
    Result := ReadDateTime(Section, Name, Default);
--- 103,127 ----
  end;
  
! procedure TCustomIniFile.WriteInteger(Section, Name: string; Value: Longint); 
  begin
    WriteString(Section, Name, Value.ToString);
  end;
  
! function TCustomIniFile.ReadBool(Section, Name: string; Default: Boolean): Boolean; 
  begin
    Result := ReadInteger(Section, Name, Ord(Default)) <> 0;
  end;
  
! procedure TCustomIniFile.WriteBool(Section, Name: string; Value: Boolean); 
  begin
    WriteInteger(Section, Name, Ord(Value));
  end;
  
! function TCustomIniFile.ReadBinaryStream(Section, Name: string; Value: TStream): Integer; 
  begin
    NotImplemented;
  end;
  
! function TCustomIniFile.ReadDate(Section, Name: string; Default: TDateTime): TDateTime; 
  begin
    Result := ReadDateTime(Section, Name, Default);
***************
*** 129,138 ****
  end;
  
! function TCustomIniFile.ReadDateTime(const Section, Name: string; Default: TDateTime): TDateTime; 
  begin
    Result := StrToDateTimeDef(ReadString(Section, Name, ''), Default);
  end;
  
! function TCustomIniFile.ReadFloat(const Section, Name: string; Default: Double): Double; 
  var S:string;
  begin
--- 129,138 ----
  end;
  
! function TCustomIniFile.ReadDateTime(Section, Name: string; Default: TDateTime): TDateTime; 
  begin
    Result := StrToDateTimeDef(ReadString(Section, Name, ''), Default);
  end;
  
! function TCustomIniFile.ReadFloat(Section, Name: string; Default: Double): Double; 
  var S:string;
  begin
***************
*** 149,153 ****
  end;
  
! function TCustomIniFile.ReadTime(const Section, Name: string; Default: TDateTime): TDateTime; 
  begin
    Result := StrToDateTimeDef(ReadString(Section, Name, ''), Default);
--- 149,153 ----
  end;
  
! function TCustomIniFile.ReadTime(Section, Name: string; Default: TDateTime): TDateTime; 
  begin
    Result := StrToDateTimeDef(ReadString(Section, Name, ''), Default);
***************
*** 155,164 ****
  end;
  
! procedure TCustomIniFile.WriteBinaryStream(const Section, Name: string; Value: TStream); 
  begin
    NotImplemented;
  end;
  
! procedure TCustomIniFile.WriteDate(const Section, Name: string; Value: TDateTime); 
  begin
    Value.Time := 0;
--- 155,164 ----
  end;
  
! procedure TCustomIniFile.WriteBinaryStream(Section, Name: string; Value: TStream); 
  begin
    NotImplemented;
  end;
  
! procedure TCustomIniFile.WriteDate(Section, Name: string; Value: TDateTime); 
  begin
    Value.Time := 0;
***************
*** 166,180 ****
  end;
  
! procedure TCustomIniFile.WriteDateTime(const Section, Name: string; Value: TDateTime); 
  begin
    WriteString(Section, Name, Value.ToString);
  end;
  
! procedure TCustomIniFile.WriteFloat(const Section, Name: string; Value: Double); 
  begin
    WriteString(Section, Name, Value.ToString);
  end;
  
! procedure TCustomIniFile.WriteTime(const Section, Name: string; Value: TDateTime); 
  begin
    Value.Date := 0;
--- 166,180 ----
  end;
  
! procedure TCustomIniFile.WriteDateTime(Section, Name: string; Value: TDateTime); 
  begin
    WriteString(Section, Name, Value.ToString);
  end;
  
! procedure TCustomIniFile.WriteFloat(Section, Name: string; Value: Double); 
  begin
    WriteString(Section, Name, Value.ToString);
  end;
  
! procedure TCustomIniFile.WriteTime(Section, Name: string; Value: TDateTime); 
  begin
    Value.Date := 0;
***************
*** 182,186 ****
  end;
  
! function TCustomIniFile.ValueExists(const Section, Name: string): Boolean; 
  var
    S: TStringlist;
--- 182,186 ----
  end;
  
! function TCustomIniFile.ValueExists(Section, Name: string): Boolean; 
  var
    S: TStringlist;
***************
*** 193,197 ****
  { TMemIniFile }
  
! function TMemIniFile.AddSection(const Section: string): TStrings; 
  var i:integer;
  begin
--- 193,197 ----
  { TMemIniFile }
  
! function TMemIniFile.AddSection(Section: string): TStrings; 
  var i:integer;
  begin
***************
*** 216,220 ****
  end;
  
! constructor TMemIniFile.Create(const FileName: string); 
  begin
    inherited Create(Filename);
--- 216,220 ----
  end;
  
! constructor TMemIniFile.Create(FileName: string); 
  begin
    inherited Create(Filename);
***************
*** 234,238 ****
  end;
  
! procedure TMemIniFile.DeleteKey(const Section, Name: String); 
  var i, j:integer;
  begin
--- 234,238 ----
  end;
  
! procedure TMemIniFile.DeleteKey(Section, Name: String); 
  var i, j:integer;
  begin
***************
*** 248,252 ****
  end;
  
! procedure TMemIniFile.EraseSection(const Section: string); 
  var i:integer;
  begin
--- 248,252 ----
  end;
  
! procedure TMemIniFile.EraseSection(Section: string); 
  var i:integer;
  begin
***************
*** 267,271 ****
  end;
  
! procedure TMemIniFile.ReadSection(const Section: string; Strings: TStrings); 
  var i:integer;
  begin
--- 267,271 ----
  end;
  
! procedure TMemIniFile.ReadSection(Section: string; Strings: TStrings); 
  var i:integer;
  begin
***************
*** 282,286 ****
  end;
  
! procedure TMemIniFile.ReadSectionValues(const Section: string; Strings: TStrings); 
  var i:integer;
  begin
--- 282,286 ----
  end;
  
! procedure TMemIniFile.ReadSectionValues(Section: string; Strings: TStrings); 
  var i:integer;
  begin
***************
*** 291,295 ****
  end;
  
! function TMemIniFile.ReadString(const Section, Name, Default: string): string; 
  var 
    i:integer;
--- 291,295 ----
  end;
  
! function TMemIniFile.ReadString(Section, Name, Default: string): string; 
  var 
    i:integer;
***************
*** 307,311 ****
  end;
  
! procedure TMemIniFile.Rename(const FileName: string; Reload: Boolean); 
  begin
    FFilename := Filename;
--- 307,311 ----
  end;
  
! procedure TMemIniFile.Rename(FileName: string; Reload: Boolean); 
  begin
    FFilename := Filename;
***************
*** 349,353 ****
  end;
  
! procedure TMemIniFile.WriteString(const Section, Name, Value: String); 
  var 
    S:TStrings;
--- 349,353 ----
  end;
  
! procedure TMemIniFile.WriteString(Section, Name, Value: String); 
  var 
    S:TStrings;

Index: SysUtils.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/SysUtils.pas,v
retrieving revision 1.7
retrieving revision 1.8
diff -C2 -d -r1.7 -r1.8
*** SysUtils.pas	26 May 2005 14:30:08 -0000	1.7
--- SysUtils.pas	26 May 2005 23:44:35 -0000	1.8
***************
*** 22,31 ****
    SysUtils = public sealed class
    public
!     class function AnsiUpperCase(const S: string): string;
!     class function AnsiLowerCase(const S: string): string;
!     class function AnsiCompareStr(const S1, S2: string): Integer;
!     class function AnsiSameStr(const S1, S2: string): Boolean;
!     class function AnsiCompareText(const S1, S2: string): Integer;
!     class function AnsiSameText(const S1, S2: string): Boolean;
      class function AnsiStrComp(S1, S2: string): Integer;
      class function AnsiStrIComp(S1, S2: string): Integer;
[...1687 lines suppressed...]
    
! function StringReplace(const S, OldPattern, NewPattern: string; Flags: TReplaceFlags): string;
  begin
    Result := ShineOn.RTL.SysUtils.StringReplace(S, OldPattern, NewPattern, Flags);
  end;
    
! function GetEnvironmentVariable(const Name: string): string;   
  begin
    Result := ShineOn.RTL.SysUtils.GetEnvironmentVariable(Name);
--- 1214,1223 ----
  end;
    
! function StringReplace(S, OldPattern, NewPattern: string; Flags: TReplaceFlags): string;
  begin
    Result := ShineOn.RTL.SysUtils.StringReplace(S, OldPattern, NewPattern, Flags);
  end;
    
! function GetEnvironmentVariable(Name: string): string;   
  begin
    Result := ShineOn.RTL.SysUtils.GetEnvironmentVariable(Name);

Index: System.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/System.pas,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** System.pas	26 May 2005 23:40:04 -0000	1.5
--- System.pas	26 May 2005 23:44:35 -0000	1.6
***************
*** 18,29 ****
    System = public sealed class 
    public
!     class function Pos(const SubStr, Str:string):integer;
!     class function Concat(const S1, S2:string):string;
      class procedure Delete(var S: string; Index, Count:Integer);
!     class procedure Insert(const Source: string; var S: string; Index: Integer);
!     class function Copy(const Source:string; StartIndex, Length: Integer):string;
  
      class procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
!     class procedure Val(const S:string; var V:Double; var Code: Integer);
  
      class function Ord(Value:Char):integer;
--- 18,29 ----
    System = public sealed class 
    public
!     class function Pos(SubStr, Str:string):integer;
!     class function Concat(S1, S2:string):string;
      class procedure Delete(var S: string; Index, Count:Integer);
!     class procedure Insert(Source: string; var S: string; Index: Integer);
!     class function Copy(Source:string; StartIndex, Length: Integer):string;
  
      class procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
!     class procedure Val(S:string; var V:Double; var Code: Integer);
  
      class function Ord(Value:Char):integer;
***************
*** 58,74 ****
  
      class procedure SetLength(var S; Length: integer);
!     class procedure Write(const S:string);
!     class procedure WriteLn(const S:string);
      class procedure Read(var P);
      class procedure ReadLn(var P);
    end;
    
! function Pos(const SubStr, Str:string):integer;
! function Concat(const S1, S2:string):string;
  procedure Delete(var S: string; Index, Count:Integer);
! procedure Insert(const Source: string; var S: string; Index: Integer);
! function Copy(const Source:string; StartIndex, Length: Integer):string;
  procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
! procedure Val(const S:string; var V:Double; var Code: Integer);
  function Ord(Value:Char):integer;
  function Ord(Value:Boolean):integer;
--- 58,74 ----
  
      class procedure SetLength(var S; Length: integer);
!     class procedure Write(S:string);
!     class procedure WriteLn(S:string);
      class procedure Read(var P);
      class procedure ReadLn(var P);
    end;
    
! function Pos(SubStr, Str:string):integer;
! function Concat(S1, S2:string):string;
  procedure Delete(var S: string; Index, Count:Integer);
! procedure Insert(Source: string; var S: string; Index: Integer);
! function Copy(Source:string; StartIndex, Length: Integer):string;
  procedure Str(X:Double; Width:integer;Decimals:integer;var S:string);
! procedure Val(S:string; var V:Double; var Code: Integer);
  function Ord(Value:Char):integer;
  function Ord(Value:Boolean):integer;
***************
*** 93,98 ****
  function Exp(X: Double): Double;
  procedure SetLength(var S; Length: integer);
! procedure Write(const S:string);
! procedure WriteLn(const S:string);
  procedure Read(var P);
  procedure ReadLn(var P);
--- 93,98 ----
  function Exp(X: Double): Double;
  procedure SetLength(var S; Length: integer);
! procedure Write(S:string);
! procedure WriteLn(S:string);
  procedure Read(var P);
  procedure ReadLn(var P);
***************
*** 102,106 ****
  
  
! class function System.Pos(const SubStr, Str:string):integer;
  begin
    //TODO: Should this function return 0 or -1 if substr not found?
--- 102,106 ----
  
  
! class function System.Pos(SubStr, Str:string):integer;
  begin
    //TODO: Should this function return 0 or -1 if substr not found?
***************
*** 108,112 ****
  end;
  
! class function System.Concat(const S1, S2:string):string;
  begin
    Result := S1 + S2;
--- 108,112 ----
  end;
  
! class function System.Concat(S1, S2:string):string;
  begin
    Result := S1 + S2;
***************
*** 123,127 ****
  end;
  
! class function System.Copy(const Source:string; StartIndex, Length: Integer):string;
  begin
    if Source = nil then
--- 123,127 ----
  end;
  
! class function System.Copy(Source:string; StartIndex, Length: Integer):string;
  begin
    if Source = nil then
***************
*** 136,140 ****
  end;
  
! class procedure System.Val(const S:string; var V:Double; var Code: Integer);
  begin
    // TODO: should we use NumberFormatInfo.CurrentInfo here?
--- 136,140 ----
  end;
  
! class procedure System.Val(S:string; var V:Double; var Code: Integer);
  begin
    // TODO: should we use NumberFormatInfo.CurrentInfo here?
***************
*** 297,306 ****
  end;
  
! class procedure System.WriteLn(const S:string);
  begin
    Console.WriteLine(S);
  end;
  
! class procedure System.Write(const S:string);
  begin
    Console.Write(S);
--- 297,306 ----
  end;
  
! class procedure System.WriteLn(S:string);
  begin
    Console.WriteLine(S);
  end;
  
! class procedure System.Write(S:string);
  begin
    Console.Write(S);
***************
*** 324,333 ****
  // DELPHI COMPATIBLE GLOBAL METHODS
  
! function Pos(const SubStr, Str:string):integer;
  begin
    Result := ShineOn.RTL.System.Pos(SubStr, Str);
  end;
    
! function Concat(const S1, S2:string):string;
  begin
    Result := ShineOn.RTL.System.Concat(S1, S2);
--- 324,333 ----
  // DELPHI COMPATIBLE GLOBAL METHODS
  
! function Pos(SubStr, Str:string):integer;
  begin
    Result := ShineOn.RTL.System.Pos(SubStr, Str);
  end;
    
! function Concat(S1, S2:string):string;
  begin
    Result := ShineOn.RTL.System.Concat(S1, S2);
***************
*** 339,348 ****
  end;
    
! procedure Insert(const Source: string; var S: string; Index: Integer);
  begin
    ShineOn.RTL.System.Insert(Source, S, Index);
  end;
    
! function Copy(const Source:string; StartIndex, Length: Integer):string;
  begin
    Result := ShineOn.RTL.System.Copy(Source, StartIndex, Length);
--- 339,348 ----
  end;
    
! procedure Insert(Source: string; var S: string; Index: Integer);
  begin
    ShineOn.RTL.System.Insert(Source, S, Index);
  end;
    
! function Copy(Source:string; StartIndex, Length: Integer):string;
  begin
    Result := ShineOn.RTL.System.Copy(Source, StartIndex, Length);
***************
*** 354,358 ****
  end;
    
! procedure Val(const S:string; var V:Double; var Code: Integer);
  begin
    ShineOn.RTL.System.Val(S, V, Code);
--- 354,358 ----
  end;
    
! procedure Val(S:string; var V:Double; var Code: Integer);
  begin
    ShineOn.RTL.System.Val(S, V, Code);
***************
*** 485,494 ****
  end;
    
! procedure Write(const S:string);
  begin
    ShineOn.RTL.System.Write(S);
  end;
    
! procedure WriteLn(const S:string);
  begin
    ShineOn.RTL.System.WriteLn(S);
--- 485,494 ----
  end;
    
! procedure Write(S:string);
  begin
    ShineOn.RTL.System.Write(S);
  end;
    
! procedure WriteLn(S:string);
  begin
    ShineOn.RTL.System.WriteLn(S);

Index: Types.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Types.pas,v
retrieving revision 1.5
retrieving revision 1.6
diff -C2 -d -r1.5 -r1.6
*** Types.pas	26 May 2005 14:30:08 -0000	1.5
--- Types.pas	26 May 2005 23:44:35 -0000	1.6
***************
*** 191,195 ****
  
    TNotifyEvent = public procedure(Sender: Object) of object;
!   TGetStrProc = public procedure(const S: string) of object;
  
  { Exception classes }
--- 191,195 ----
  
    TNotifyEvent = public procedure(Sender: Object) of object;
!   TGetStrProc = public procedure(S: string) of object;
  
  { Exception classes }



From nobody at sheep.berlios.de  Sun May 29 21:47:59 2005
From: nobody at sheep.berlios.de (peter3)
Date: Sun, 29 May 2005 21:47:59 +0200
Subject: [Shineon-checkins] ShineOn/ShineOn.RTL Classes.pas,1.8,1.9 Globals.pas,1.3,1.4 SysUtils.pas,1.8,1.9 System.pas,1.6,1.7 Types.pas,1.6,1.7
Message-ID: <200505291947.j4TJlxm29835@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/ShineOn.RTL
In directory sheep:/tmp/cvs-serv3041/ShineOn.RTL

Modified Files:
	Classes.pas Globals.pas SysUtils.pas System.pas Types.pas 
Log Message:
- MinValue and MaxValue for TDateTime
- FreeAndNil now class Free if the class is a TObject (so BeforeDestruction is called)
- Changes to StrToInt implementations (allows hex specifiers)
- Sqr(t) global functions wasn't public
- Several base TObject class and instance methods implemented
- Several Min/Max constants added

Index: Classes.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Classes.pas,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** Classes.pas	26 May 2005 23:44:35 -0000	1.8
--- Classes.pas	29 May 2005 19:47:57 -0000	1.9
***************
*** 25,34 ****
    System.Threading,
    System.Collections,
!   System.Windows.Forms;
    
  type
    TObject = public class(System.Object)
    public
      procedure Free; 
      procedure Destroy;virtual;
    end;
--- 25,63 ----
    System.Threading,
    System.Collections,
!   System.Reflection,
!   System.Windows.Forms; // for Form
    
  type
    TObject = public class(System.Object)
+   private
+   protected
+     class var _ClassType:TClass := nil;
+     class var _ClassInfo:System.Type := nil;
    public
+     class function InitInstance(Instance: Object): TObject;
+     procedure CleanupInstance;
+     function ClassType: TClass;
+     class function ClassName: string;
+     class function ClassNameIs(const Name: string): Boolean;
+     class function ClassParent: TClass;
+     class function ClassInfo: System.Type;
+     class function InstanceSize: Longint;
+     class function InheritsFrom(AClass: TClass): Boolean;
+     class function MethodAddress(const Name: string): MemberInfo;
+     class function MethodName(Address: MemberInfo): string;
+     function FieldAddress(const Name: string): FieldInfo;
+     function GetInterface(const IID: TGUID; out Obj): Boolean;
+     class function GetInterfaceEntry(const IID: TGUID): Object;
+     class function GetInterfaceTable: Object;
+     function SafeCallException(ExceptObject: TObject; ExceptAddr: Object): HResult; virtual;
+     procedure AfterConstruction; virtual;
+     procedure BeforeDestruction; virtual;
+     procedure Dispatch(var Message); virtual;
+     procedure DefaultHandler(var Message); virtual;
+     class function NewInstance: TObject; virtual;
+     procedure FreeInstance; virtual;
+     
      procedure Free; 
+     constructor Create;
      procedure Destroy;virtual;
    end;
***************
*** 36,40 ****
    TClass = public class of TObject;
  
!   TComponent = public System.ComponentModel.Component;  // for now...
    
    TListSortCompare = public function (Item1, Item2: Object): Integer;
--- 65,69 ----
    TClass = public class of TObject;
  
!   TComponent = public class(System.ComponentModel.Component);  // for now...
    
    TListSortCompare = public function (Item1, Item2: Object): Integer;
***************
*** 566,571 ****
--- 595,753 ----
  end;
  
+ { TObject }
+ 
+ class function TObject.InitInstance(Instance: Object): TObject;
+ begin
+   Result := Instance as TObject;
+ end;
+ 
+ procedure TObject.CleanupInstance;
+ begin
+   // 
+ end;
+ 
+ function TObject.ClassType: TClass;
+ var
+   MetaClassType :System.Type;
+   MetaClassInstanceProperty :PropertyInfo;
+ begin
+   if not Assigned(_ClassType) then
+   begin
+     MetaClassType := GetType().GetNestedType('MetaClass');
+     MetaClassInstanceProperty := MetaClassType.GetProperty('Instance');
+     _ClassType := TClass(MetaClassInstanceProperty.GetValue(nil, nil));
+   end;
+   Result := _ClassType; 
+ end;
+ 
+ class function TObject.ClassName: string;
+ begin
+   Result := ClassInfo.Name;
+ end;
+ 
+ class function TObject.ClassNameIs(const Name: string): Boolean;
+ begin
+   Result := System.String.Compare(Name, self.ClassName, true) = 0;
+ end;
+ 
+ class function TObject.ClassParent: TClass;
+ var t:System.Type;
+ begin
+   t := _ClassInfo.BaseType;
+   if t is TObject then
+     Result := TObject(t).ClassType
+   else
+     t := nil;
+ end;
+ 
+ class function TObject.ClassInfo: System.Type;
+ begin
+   if _ClassInfo = nil then
+     _ClassInfo := typeof(self);
+   Result := _ClassInfo;
+ end;
+ 
+ class function TObject.InstanceSize: Longint;
+ begin
+   Result := 0; // TODO: find a way to get the instance size for classes
+ end;
+ 
+ class function TObject.InheritsFrom(AClass: TClass): Boolean;
+ begin
+   if (AClass = nil) then
+     Result := false
+   else
+     Result := AClass.ActualType.IsAssignableFrom(Self.ClassInfo);
+ end;
+ 
+ class function TObject.MethodAddress(const Name: string): MemberInfo;
+ var meminfo:array of MemberInfo;
+ begin
+   meminfo := ClassInfo.GetMember(Name);
+   if meminfo.Length > 0 then
+     Result := meminfo[0]
+   else
+     Result := nil;
+ end;
+ 
+ class function TObject.MethodName(Address: MemberInfo): string;
+ begin
+   Result := Address.Name;
+ end;
+ 
+ function TObject.FieldAddress(const Name: string): FieldInfo;
+ begin
+   Result := ClassInfo.GetField(Name);
+ end;
+ 
+ function TObject.GetInterface(const IID: TGUID; out Obj): Boolean;
+ begin
+   try
+     Obj := ClassInfo.GetTypeFromCLSID(IID);
+     Result := true;
+   except
+     Obj := nil;
+     Result := false;
+   end;   
+ end;
+ 
+ class function TObject.GetInterfaceEntry(const IID: TGUID): Object;
+ begin
+   try
+     Result := ClassInfo.GetTypeFromCLSID(IID);
+   except
+     Result := nil;
+   end;   
+ end;
+ 
+ class function TObject.GetInterfaceTable: Object;
+ begin
+   Result := ClassInfo.GetInterfaces;
+ end;
+ 
+ function TObject.SafeCallException(ExceptObject: TObject; ExceptAddr: Object): HResult; 
+ begin
+   NotImplemented;
+ end;
+ 
+ procedure TObject.AfterConstruction;
+ begin
+   // do nothing
+ end;
+ 
+ procedure TObject.BeforeDestruction; 
+ begin
+   // do nothing
+ end;
+ 
+ procedure TObject.Dispatch(var Message); 
+ begin
+   NotImplemented;
+ end;
+ 
+ procedure TObject.DefaultHandler(var Message); 
+ begin
+   NotImplemented;
+ end;
+ 
+ class function TObject.NewInstance: TObject; 
+ begin
+   Result := new TObject;
+ end;
+ 
+ procedure TObject.FreeInstance; 
+ begin
+   // do nothing
+ end;
+ 
+ constructor TObject.Create;
+ begin
+   inherited Create;
+   AfterConstruction;
+ end;
+   
  procedure TObject.Destroy;
  begin
+   BeforeDestruction;
    if Self is IDisposable then
      IDisposable(Self).Dispose;
***************
*** 2053,2063 ****
  
  procedure TMemoryStream.LoadFromFile(FileName: string);
! var f:TFIleStream;
  begin
!   f := new TFileStream(Filename, fmOpenRead or fmShareDenyWrite);
    try
      LoadFromStream(f);
    finally
!     f.Free;
    end;
  end;
--- 2235,2245 ----
  
  procedure TMemoryStream.LoadFromFile(FileName: string);
! var F:TFileStream;
  begin
!   F := new TFileStream(Filename, fmOpenRead or fmShareDenyWrite);
    try
      LoadFromStream(f);
    finally
!     F.Free;
    end;
  end;

Index: Globals.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Globals.pas,v
retrieving revision 1.3
retrieving revision 1.4
diff -C2 -d -r1.3 -r1.4
*** Globals.pas	26 May 2005 23:44:35 -0000	1.3
--- Globals.pas	29 May 2005 19:47:57 -0000	1.4
***************
*** 13,20 ****
  // should be placed in Consts.pas).
  
! // To add a new variable, add it as a class variable to the Globals class and then add a global variable
  // pointing to the global class var. This makes the definitions useable from other languages besides Chrome.
  
! // To add a new constant, add it as a class constant to the Globals class and then add a global constant
  // pointing to the class constant. This makes the definitions useable from other languages besides Chrome.
  
--- 13,20 ----
  // should be placed in Consts.pas).
  
! // To add a new variable, add it as a public class variable to the Globals class and then add a global variable
  // pointing to the global class var. This makes the definitions useable from other languages besides Chrome.
  
! // To add a new constant, add it as a public class constant to the Globals class and then add a global constant
  // pointing to the class constant. This makes the definitions useable from other languages besides Chrome.
  
***************
*** 24,34 ****
  
  type
!   Globals = public class
    public
      class var ApplicationMainForm:Form := nil; // used by TThread.Synchronize();
    public
!     class const MaxInt:integer = 2147483647;
!     class const MaxLongint:Longint = 2147483647;
      class const MaxListSize = MaxInt div 16;
      class const soFromBeginning = 0;
      class const soFromCurrent = 1;
--- 24,45 ----
  
  type
!   Globals = public sealed class
    public
      class var ApplicationMainForm:Form := nil; // used by TThread.Synchronize();
    public
!     class const MaxInt:integer = Int16.MaxValue;
!     class const MaxLongint:Longint = UInt32.MaxValue;
      class const MaxListSize = MaxInt div 16;
+     class const MaxComp:Int64 = Int64.MaxValue;
+     class const MaxDouble: Double = Double.MaxValue;
+     class const MaxExtended: Extended = Extended.MaxValue;
+     class const MaxSingle:Single = Single.MaxValue;
+     class const MinComp:Int64 = Int64.MinValue;
+     class const MinDouble: Double = Double.MinValue;
+     class const MinExtended: Extended = Extended.MinValue;
+     class const MinSingle: Single = Single.MinValue;
+     // TODO: figure out how to declare these as consts isto vars:
+     class var MaxDateTime:TDateTime := new TDateTime(2958465.99999);
+     class var MinDateTime:TDateTime := new TDateTime(-657434.0);
      class const soFromBeginning = 0;
      class const soFromCurrent = 1;
***************
*** 109,112 ****
--- 120,131 ----
    MaxLongint = Globals.MaxLongint;
    MaxListSize = Globals.MaxListSize;
+   MaxComp = Globals.MaxComp;
+   MaxDouble = Globals.MaxDouble;
+   MaxExtended = Globals.MaxExtended;
+   MaxSingle = Globals.MaxSingle;
+   MinComp = Globals.MinComp;
+   MinDouble = Globals.MinDouble;
+   MinExtended = Globals.MinExtended;
+   MinSingle = Globals.MinSingle;
  
    soFromBeginning = Globals.soFromBeginning;
***************
*** 208,211 ****
--- 227,232 ----
  var
   ApplicationMainForm:Form := Globals.ApplicationMainForm;
+  MaxDateTime:TDateTime := Globals.MaxDateTime;
+  MinDateTime:TDateTime := Globals.MinDateTime;
    
  

Index: SysUtils.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/SysUtils.pas,v
retrieving revision 1.8
retrieving revision 1.9
diff -C2 -d -r1.8 -r1.9
*** SysUtils.pas	26 May 2005 23:44:35 -0000	1.8
--- SysUtils.pas	29 May 2005 19:47:57 -0000	1.9
***************
*** 14,17 ****
--- 14,19 ----
  
  interface
+ uses
+   System.Globalization;
  
  type
***************
*** 90,95 ****
--- 92,99 ----
      class function IsDelimiter(Delimiters, S: string; Index: Integer): Boolean;
      class function IncludeTrailingPathDelimiter(S: string): string;
+     [Obsolete('This method has been replaced by IncludeTrailingPathDelimiter')]
      class function IncludeTrailingBackslash(S: string): string; 
      class function ExcludeTrailingPathDelimiter(S: string): string;
+     [Obsolete('This method has been replaced by ExcludeTrailingPathDelimiter')]
      class function ExcludeTrailingBackslash(S: string): string;
      class function LastDelimiter(Delimiters, S: string): Integer;
***************
*** 174,179 ****
--- 178,185 ----
  function IsDelimiter(Delimiters, S: string; Index: Integer): Boolean;
  function IncludeTrailingPathDelimiter(S: string): string;
+ [Obsolete('This method has been replaced by IncludeTrailingPathDelimiter')]
  function IncludeTrailingBackslash(S: string): string; 
  function ExcludeTrailingPathDelimiter(S: string): string;
+ [Obsolete('This method has been replaced by ExcludeTrailingPathDelimiter')]
  function ExcludeTrailingBackslash(S: string): string;
  function LastDelimiter(Delimiters, S: string): Integer;
***************
*** 198,202 ****
--- 204,210 ----
  procedure NotImplemented;
  begin
+   {$IFNDEF SHINEON_DISABLE_NOTIMPLEMENTED_ERROR}
    raise EShineOnError.Create('Not implemented');
+   {$ENDIF} 
  end;
  
***************
*** 373,377 ****
  class function SysUtils.StrToInt(S: string): Integer;
  begin
!   Result := Int32.Parse(S);
  end;
  
--- 381,388 ----
  class function SysUtils.StrToInt(S: string): Integer;
  begin
!   if S.StartsWith('$') then
!     Result := Int32.Parse(S.SubString(1),NumberStyles.AllowHexSpecifier)
!   else
!     Result := Int32.Parse(S);
  end;
  
***************
*** 387,393 ****
    Result := true;
    try
!     Value := Int32.Parse(S);
    except
!    Result := false;
    end;
  end;
--- 398,404 ----
    Result := true;
    try
!     Value := StrToInt(S);
    except
!     Result := false;
    end;
  end;
***************
*** 395,399 ****
  class function SysUtils.StrToInt64(S: string): Int64;
  begin
!   Result := Int64.Parse(S);
  end;
  
--- 406,413 ----
  class function SysUtils.StrToInt64(S: string): Int64;
  begin
!   if S.StartsWith('$') then
!     Result := Int64.Parse(S.SubString(1),NumberStyles.AllowHexSpecifier)
!   else
!     Result := Int64.Parse(S);
  end;
  
***************
*** 408,412 ****
    Result := true;
    try
!     Value := Int64.Parse(S);
    except
      Result := false;
--- 422,426 ----
    Result := true;
    try
!     Value := StrToInt64(S);
    except
      Result := false;
***************
*** 498,502 ****
  class procedure SysUtils.FreeAndNil(var obj);
  begin
!   if Object(Obj) is IDisposable then
      IDisposable(Obj).Dispose;
    Obj := nil;
--- 512,518 ----
  class procedure SysUtils.FreeAndNil(var obj);
  begin
!   if Obj is TObject then
!     TObject(Obj).Free
!   else if Obj is IDisposable then
      IDisposable(Obj).Dispose;
    Obj := nil;
***************
*** 513,516 ****
--- 529,535 ----
  end;
  
+ {TODO: These following methods shouldn't catch ALL exceptions, but only the /expected/
+        exceptions that will be thrown if the IO operation failed. }
+ 
  class function SysUtils.ForceDirectories(Dir: string): Boolean;
  begin
***************
*** 634,638 ****
  end;
  
! {ToDo: These following methds shouldn't catch ALL exceptions, but only the /expected/
         exceptions that will be thrown if the IO operation failed. }
  
--- 653,657 ----
  end;
  
! {TODO: These following methods shouldn't catch ALL exceptions, but only the /expected/
         exceptions that will be thrown if the IO operation failed. }
  
***************
*** 1156,1160 ****
  function IncludeTrailingBackslash(S: string): string; 
  begin
!   Result := ShineOn.RTL.SysUtils.IncludeTrailingBackslash(S);
  end;
    
--- 1175,1179 ----
  function IncludeTrailingBackslash(S: string): string; 
  begin
!   Result := ShineOn.RTL.SysUtils.IncludeTrailingPathDelimiter(S);
  end;
    
***************
*** 1166,1170 ****
  function ExcludeTrailingBackslash(S: string): string;
  begin
!   Result := ShineOn.RTL.SysUtils.ExcludeTrailingBackslash(S);
  end;
    
--- 1185,1189 ----
  function ExcludeTrailingBackslash(S: string): string;
  begin
!   Result := ShineOn.RTL.SysUtils.ExcludeTrailingPathDelimiter(S);
  end;
    

Index: System.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/System.pas,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** System.pas	26 May 2005 23:44:35 -0000	1.6
--- System.pas	29 May 2005 19:47:57 -0000	1.7
***************
*** 88,91 ****
--- 88,95 ----
  function Frac(Value:TDateTime):Double;
  function Odd(Value:Integer):boolean;
+ function Sqrt(Number:Extended):Extended; 
+ function Sqr(Number:Extended):Extended; 
+ function Sqr(Number:Integer):Integer; 
+ 
  function Abs(X:Integer):Integer;
  function Abs(X:Double):Double;

Index: Types.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/ShineOn.RTL/Types.pas,v
retrieving revision 1.6
retrieving revision 1.7
diff -C2 -d -r1.6 -r1.7
*** Types.pas	26 May 2005 23:44:35 -0000	1.6
--- Types.pas	29 May 2005 19:47:57 -0000	1.7
***************
*** 183,187 ****
  { Types used by standard events }
  type
! 
  //!!!  THelpContext = -MaxLongint..MaxLongint; // not supported by Chrome
  
--- 183,187 ----
  { Types used by standard events }
  type
!   
  //!!!  THelpContext = -MaxLongint..MaxLongint; // not supported by Chrome
  
***************
*** 230,234 ****
    
    
!   TDateTime = public class // TODO: experimental. Might reduce this to a struct or simple double/DateTime alias
    private
      FDateTime:DateTime;
--- 230,234 ----
    
    
!   TDateTime = public record // TODO: experimental. Might reduce this to a struct or simple double/DateTime alias
    private
      FDateTime:DateTime;
***************
*** 248,251 ****
--- 248,254 ----
      constructor (ATime:TimeSpan);
  
+     class method MinValue: TDateTime; virtual; final;
+     class method MaxValue: TDateTime; virtual; final;
+ 
      class method Parse(S:String):TDateTime;
      class method Parse(S:string; FormatProvider:IFormatProvider):TDateTime;
***************
*** 271,277 ****
      class operator Plus(aOperand: TDateTime) : TDateTime; 
      class operator Explicit(aValue: TDateTime): Integer;
!     
!     // class operator Explicit(aValue: TDateTime): TimeSpan;
!     
      class operator Implicit(aValue: TDateTime): DateTime;
      class operator Implicit(aValue: DateTime): TDateTime;
--- 274,278 ----
      class operator Plus(aOperand: TDateTime) : TDateTime; 
      class operator Explicit(aValue: TDateTime): Integer;
! //    class operator Explicit(aValue: TDateTime): TimeSpan;
      class operator Implicit(aValue: TDateTime): DateTime;
      class operator Implicit(aValue: DateTime): TDateTime;
***************
*** 473,476 ****
--- 474,488 ----
    Result := new TDateTime(aValue);
  end;
+ 
+ class method TDateTime.MinValue: TDateTime; 
+ begin
+   Result := new TDateTime(-657434.0);
+ end;
+ 
+ class method TDateTime.MaxValue: TDateTime; 
+ begin
+   Result := new TDateTime(2958465.99999);
+ end;
+ 
  
  end.



From nobody at sheep.berlios.de  Mon May 30 15:42:32 2005
From: nobody at sheep.berlios.de (peter3)
Date: Mon, 30 May 2005 15:42:32 +0200
Subject: [Shineon-checkins] ShineOn/NUnit - New directory
Message-ID: <200505301342.j4UDgWm26882@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/NUnit
In directory sheep:/tmp/cvs-serv2312/NUnit

Log Message:
Directory /cvsroot/shineon/ShineOn/NUnit added to the repository




From nobody at sheep.berlios.de  Mon May 30 15:43:35 2005
From: nobody at sheep.berlios.de (peter3)
Date: Mon, 30 May 2005 15:43:35 +0200
Subject: [Shineon-checkins] ShineOn/NUnit AssemblyInfo.pas,NONE,1.1 NUnit.ShineOn.RTL.2003.sln,NONE,1.1 NUnit.ShineOn.RTL.chrome,NONE,1.1 TestMain.pas,NONE,1.1
Message-ID: <200505301343.j4UDhZm26911@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/NUnit
In directory sheep:/tmp/cvs-serv2469/NUnit

Added Files:
	AssemblyInfo.pas NUnit.ShineOn.RTL.2003.sln 
	NUnit.ShineOn.RTL.chrome TestMain.pas 
Log Message:
- Initial NUnit test fixture
- Feel free to expand!

--- NEW FILE: AssemblyInfo.pas ---
namespace NUnit.ShineOn.RTL;

interface

uses
  System.Reflection;

[assembly: AssemblyTitle('NUnit.ShineOn.RTL')]
[assembly: AssemblyDescription('NUnit tests for ShineOn')]
[assembly: AssemblyConfiguration('')]
[assembly: AssemblyCompany('')]
[assembly: AssemblyProduct('')]
[assembly: AssemblyCopyright('')]
[assembly: AssemblyTrademark('')]
[assembly: AssemblyCulture('')]
[assembly: AssemblyVersion('1.0.0.1')]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory, which in Chrome by default is the
//       same as the project directory. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile('mykey.snk')]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile('')]
[assembly: AssemblyKeyName('')]

implementation

end.

--- NEW FILE: NUnit.ShineOn.RTL.2003.sln ---
Microsoft Visual Studio Solution File, Format Version 8.00
Project("{656346D9-4656-40DA-A068-22D5425D4639}") = "Nunit", "Nunit.ShineOn.RTL.chrome", "{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}"
	ProjectSection(ProjectDependencies) = postProject
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfiguration) = preSolution
		Debug = Debug
		Release = Release
	EndGlobalSection
	GlobalSection(ProjectConfiguration) = postSolution
		{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}.Debug.ActiveCfg = Debug
		{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}.Debug.Build.0 = Debug
		{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}.Release.ActiveCfg = Release
		{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}.Release.Build.0 = Release
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
	EndGlobalSection
	GlobalSection(ExtensibilityAddIns) = postSolution
	EndGlobalSection
EndGlobal

--- NEW FILE: NUnit.ShineOn.RTL.chrome ---
<ChromeProject>
  <ProjectOptions Name="NUnit.ShineOn.RTL">
    <ProjectID>{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}</ProjectID>
    <DefaultNamespace>NUnit.ShineOn.RTL</DefaultNamespace>
    <StartupClass>
    </StartupClass>
    <OutputType>library</OutputType>
    <AssemblyName>Nunit.ShineOn.RTL</AssemblyName>
    <AllowGlobals>False</AllowGlobals>
    <AllowLegacyWith>False</AllowLegacyWith>
    <AllowLegacyOutParams>True</AllowLegacyOutParams>
    <AllowUnsafeCode>False</AllowUnsafeCode>
    <AllowLegacyCreate>True</AllowLegacyCreate>
    <ApplicationIcon>
    </ApplicationIcon>
  </ProjectOptions>
  <References>
    <Reference Assembly="$(Framework)\mscorlib.dll" Display="mscorlib" CopyLocal="False" />
    <Reference Assembly="$(Framework)\System.dll" Display="System" CopyLocal="False" />
    <Reference Assembly="$(Framework)\System.Drawing.dll" Display="System.Drawing" CopyLocal="False" />
    <Reference Assembly="$(Framework)\System.Windows.Forms.dll" Display="System.Windows.Forms" CopyLocal="False" />
    <Reference Assembly="..\..\..\..\..\NUnit 2.2\bin\nunit.framework.dll" Display="nunit.framework" CopyLocal="False" />
    <Reference Assembly="..\bin\ShineOn.RTL.dll" Display="ShineOn.RTL.dll" CopyLocal="False" />
  </References>
  <Configurations>
    <Configuration Name="Debug">
      <Conditionals>DEBUG;TRACE;</Conditionals>
      <OutputPath>..\bin</OutputPath>
      <GeneratePDB>True</GeneratePDB>
      <GenerateMDB>False</GenerateMDB>
      <EnableAsserts>True</EnableAsserts>
      <TreatWarningsAsErrors>False</TreatWarningsAsErrors>
      <CaptureConsoleOutput>False</CaptureConsoleOutput>
      <StartMode>Application</StartMode>
      <StartApp>..\..\..\..\..\NUnit 2.2\bin\nunit-gui.exe</StartApp>
      <StartAppParams>NUnit.ShineOn.RTL.dll</StartAppParams>
      <WorkingDir>..\bin</WorkingDir>
      <RegisterForComInterop>False</RegisterForComInterop>
      <CpuType>anycpu</CpuType>
      <RuntimeVersion>v25</RuntimeVersion>
      <XmlDoc>False</XmlDoc>
      <XmlDocWarningLevel>WarningOnPublicMembers</XmlDocWarningLevel>
      <EnableUnmanagedDebugging>False</EnableUnmanagedDebugging>
    </Configuration>
    <Configuration Name="Release">
      <OutputPath>..\bin</OutputPath>
      <GeneratePDB>False</GeneratePDB>
      <GenerateMDB>False</GenerateMDB>
      <EnableAsserts>False</EnableAsserts>
      <TreatWarningsAsErrors>False</TreatWarningsAsErrors>
      <CaptureConsoleOutput>False</CaptureConsoleOutput>
      <StartMode>Project</StartMode>
      <RegisterForComInterop>False</RegisterForComInterop>
      <CpuType>anycpu</CpuType>
      <RuntimeVersion>v25</RuntimeVersion>
      <XmlDoc>False</XmlDoc>
      <XmlDocWarningLevel>WarningOnPublicMembers</XmlDocWarningLevel>
      <EnableUnmanagedDebugging>False</EnableUnmanagedDebugging>
    </Configuration>
  </Configurations>
  <Files>
    <File Filename="AssemblyInfo.pas">
      <ExcludeFromBuild>False</ExcludeFromBuild>
      <BuildAction>Compile</BuildAction>
    </File>
    <File Filename="TestMain.pas">
      <ExcludeFromBuild>False</ExcludeFromBuild>
      <BuildAction>Compile</BuildAction>
    </File>
  </Files>
</ChromeProject>
--- NEW FILE: TestMain.pas ---
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); 
// you may not use this file except in compliance with the License. You may obtain a copy of the 
// License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF 
// ANY KIND, either express or implied. See the License for the specificlanguage governing rights and 
// limitations under the License.

// $Id: TestMain.pas,v 1.1 2005/05/30 13:43:32 peter3 Exp $

namespace NUnit.ShineOn.RTL;
// TODO:
// - Add test fixtures and methods for all classes and methods
// - Currently, the tests are trivial and only provided as an example 

// NOTE: you will probably have to change the Start Application path for the project to match the install folder
// on your system. You can also run the tests manually from the NUnit GUI (or console) if you prefer.

// To add a NUnit command to the Tools menu, add a new External Tool with these parameters:
// Title: NUnit
// Command: <path to nunit-gui.exe or nunit-console.exe>
// Arguments: $(TargetPath) 
// Initial Directory: $(TargetDir)

interface
uses
  Nunit.Framework,
  ShineOn.RTL;

type
  [TestFixture]
  TestSysUtils = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;

    [Test]
    method StringListAdd;
    [Test]
    method StringListDelete1;
    [Test]
    method StringListDelete2;
    [Test]
    method StringListClear;
  end;

implementation

method TestSysUtils.StringListAdd;
begin
  with T:TStringlist := new TStringlist do
  begin
    T.Add('A');
    T.Add('B');
    NUnit.Framework.Assert.AreEqual(2, T.Count, 'TStringlist.Count is wrong');
  end;
end;


method TestSysUtils.StringListDelete1; 
begin
  with T:TStringlist := new TStringlist do
  begin
    T.Add('AAA');
    T.Add('BBB');
    T.Delete(T.IndexOf('AAA'));
    NUnit.Framework.Assert.AreEqual(1, T.Count, 'TStringlist.Count is wrong');
  end;
end;

method TestSysUtils.StringListDelete2; 
begin
  with T:TStringlist := new TStringlist do
  begin
    T.Add('BBB');
    T.Add('AAA');
    T.Delete(0);
    NUnit.Framework.Assert.AreEqual(T[0], 'AAA', 'TStringlist content is wrong');
  end;
end;

method TestSysUtils.StringListClear; 
begin
  with T:TStringlist := new TStringlist do
  begin
    T.Add('AAA');
    T.Add('AAA');
    T.Add('BBB');
    T.Add('BBB');
    T.Clear;
    NUnit.Framework.Assert.AreEqual(0, T.Count, 'TStringlist.Count is wrong');
  end;
end;

method TestSysUtils.Setup; 
begin
  // add setup code here
end;

method TestSysUtils.TearDown; 
begin
  // add tear down code here
end;

end.



From nobody at sheep.berlios.de  Mon May 30 15:47:13 2005
From: nobody at sheep.berlios.de (peter3)
Date: Mon, 30 May 2005 15:47:13 +0200
Subject: [Shineon-checkins] ShineOn/NUnit TestMain.pas,1.1,1.2
Message-ID: <200505301347.j4UDlDm27036@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/NUnit
In directory sheep:/tmp/cvs-serv2748/NUnit

Modified Files:
	TestMain.pas 
Log Message:
- Renamed classes and methods to better reflect intent

Index: TestMain.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/NUnit/TestMain.pas,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** TestMain.pas	30 May 2005 13:43:32 -0000	1.1
--- TestMain.pas	30 May 2005 13:47:10 -0000	1.2
***************
*** 30,34 ****
  type
    [TestFixture]
!   TestSysUtils = public class(TestCase)
    public
      method Setup;override;
--- 30,34 ----
  type
    [TestFixture]
!   StringlistTests = public class(TestCase)
    public
      method Setup;override;
***************
*** 36,51 ****
  
      [Test]
!     method StringListAdd;
      [Test]
!     method StringListDelete1;
      [Test]
!     method StringListDelete2;
      [Test]
!     method StringListClear;
    end;
  
  implementation
  
! method TestSysUtils.StringListAdd;
  begin
    with T:TStringlist := new TStringlist do
--- 36,51 ----
  
      [Test]
!     method Add;
      [Test]
!     method Delete1;
      [Test]
!     method Delete2;
      [Test]
!     method Clear;
    end;
  
  implementation
  
! method StringlistTests.Add;
  begin
    with T:TStringlist := new TStringlist do
***************
*** 58,62 ****
  
  
! method TestSysUtils.StringListDelete1; 
  begin
    with T:TStringlist := new TStringlist do
--- 58,62 ----
  
  
! method StringlistTests.Delete1; 
  begin
    with T:TStringlist := new TStringlist do
***************
*** 69,73 ****
  end;
  
! method TestSysUtils.StringListDelete2; 
  begin
    with T:TStringlist := new TStringlist do
--- 69,73 ----
  end;
  
! method StringlistTests.Delete2; 
  begin
    with T:TStringlist := new TStringlist do
***************
*** 80,84 ****
  end;
  
! method TestSysUtils.StringListClear; 
  begin
    with T:TStringlist := new TStringlist do
--- 80,84 ----
  end;
  
! method StringlistTests.Clear; 
  begin
    with T:TStringlist := new TStringlist do
***************
*** 93,102 ****
  end;
  
! method TestSysUtils.Setup; 
  begin
    // add setup code here
  end;
  
! method TestSysUtils.TearDown; 
  begin
    // add tear down code here
--- 93,102 ----
  end;
  
! method StringlistTests.Setup; 
  begin
    // add setup code here
  end;
  
! method StringlistTests.TearDown; 
  begin
    // add tear down code here



From nobody at sheep.berlios.de  Mon May 30 15:48:13 2005
From: nobody at sheep.berlios.de (peter3)
Date: Mon, 30 May 2005 15:48:13 +0200
Subject: [Shineon-checkins] ShineOn/NUnit .cvsignore,NONE,1.1
Message-ID: <200505301348.j4UDmDm27102@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/NUnit
In directory sheep:/tmp/cvs-serv2815/NUnit

Added Files:
	.cvsignore 
Log Message:


--- NEW FILE: .cvsignore ---
*.suo


From nobody at sheep.berlios.de  Tue May 31 10:38:53 2005
From: nobody at sheep.berlios.de (peter3)
Date: Tue, 31 May 2005 10:38:53 +0200
Subject: [Shineon-checkins] ShineOn/NUnit TestClasses.pas,NONE,1.1 TestContnrs.pas,NONE,1.1 TestIniFiles.pas,NONE,1.1 TestSysUtils.pas,NONE,1.1 TestSystem.pas,NONE,1.1 AssemblyInfo.pas,1.1,1.2 NUnit.ShineOn.RTL.chrome,1.1,1.2 TestMain.pas,1.2,NONE
Message-ID: <200505310838.j4V8crm29634@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/NUnit
In directory sheep:/tmp/cvs-serv1491/NUnit

Modified Files:
	AssemblyInfo.pas NUnit.ShineOn.RTL.chrome 
Added Files:
	TestClasses.pas TestContnrs.pas TestIniFiles.pas 
	TestSysUtils.pas TestSystem.pas 
Removed Files:
	TestMain.pas 
Log Message:
- Rearranged tests into their own units
- Stubs for basic tests added

--- NEW FILE: TestClasses.pas ---
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); 
// you may not use this file except in compliance with the License. You may obtain a copy of the 
// License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF 
// ANY KIND, either express or implied. See the License for the specificlanguage governing rights and 
// limitations under the License.

// $Id: TestClasses.pas,v 1.1 2005/05/31 08:38:50 peter3 Exp $
namespace NUnit.ShineOn.RTL;

interface
uses
  Nunit.Framework,
  ShineOn.RTL;
  
type
  [TestFixture]
  TObjectTests = public class(TestCase)
[...1137 lines suppressed...]
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TThreadTests.Priority; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TThreadTests.Suspended; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TThreadTests.ThreadID; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

end.

--- NEW FILE: TestContnrs.pas ---
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); 
// you may not use this file except in compliance with the License. You may obtain a copy of the 
// License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF 
// ANY KIND, either express or implied. See the License for the specificlanguage governing rights and 
// limitations under the License.

// $Id: TestContnrs.pas,v 1.1 2005/05/31 08:38:50 peter3 Exp $
namespace NUnit.ShineOn.RTL;

interface
uses
  Nunit.Framework,
  ShineOn.RTL;

type
  [TestFixture]
  TObjectListTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;
    [Test]
    method Add;
    [Test]
    method Extract;
    [Test]
    method Remove;
    [Test]
    method IndexOf;
    [Test]
    method FindInstanceOf;
    [Test]
    method Insert;
    [Test]
    method First;
    [Test]
    method Last;
    [Test]
    method Items;
  end;

  [TestFixture]
  TComponentListTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;

    [Test]
    method Add;
    [Test]
    method Extract;
    [Test]
    method Remove;
    [Test]
    method IndexOf;
    [Test]
    method First;
    [Test]
    method Last;
    [Test]
    method Insert;
    [Test]
    method Items;
  end;

  [TestFixture]
  TClassListTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;

    [Test]
    method Add;
    [Test]
    method Extract;
    [Test]
    method Remove;
    [Test]
    method IndexOf;
    [Test]
    method First;
    [Test]
    method Last;
    [Test]
    method Insert;
    [Test]
    method Items;
  end;

  [TestFixture]
  TStackTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;

    [Test]
    method Count;
    [Test]
    method AtLeast;
    [Test]
    method Push;
    [Test]
    method Pop;
    [Test]
    method Peek;
  end;

  [TestFixture]
  TObjectStackTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;

    [Test]
    method Count;
    [Test]
    method AtLeast;
    [Test]
    method Push;
    [Test]
    method Pop;
    [Test]
    method Peek;
  end;

  [TestFixture]
  TQueueTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;

    [Test]
    method Count;
    [Test]
    method AtLeast;
    [Test]
    method Push;
    [Test]
    method Pop;
    [Test]
    method Peek;
  end;
  
  [TestFixture]
  TObjectQueueTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;

    [Test]
    method Count;
    [Test]
    method AtLeast;
    [Test]
    method Push;
    [Test]
    method Pop;
    [Test]
    method Peek;
  end;
  
  [TestFixture]
  TBucketListTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;

    [Test]
    method Clear;
    [Test]
    method Add;
    [Test]
    method Remove;
    [Test]
    method ForEach;
    [Test]
    method Assign;
    [Test]
    method Exists;
    [Test]
    method Find;
    [Test]
    method Data;
  end;

implementation

method TObjectListTests.Setup; 
begin
end;

method TObjectListTests.TearDown; 
begin
end;

method TObjectListTests.Add; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectListTests.Extract; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectListTests.Remove; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectListTests.IndexOf; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectListTests.FindInstanceOf; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectListTests.Insert; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectListTests.First; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectListTests.Last; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectListTests.Items; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TComponentListTests.Setup; 
begin
end;

method TComponentListTests.TearDown; 
begin
end;

method TComponentListTests.Add; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TComponentListTests.Extract; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TComponentListTests.Remove; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TComponentListTests.IndexOf; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TComponentListTests.First; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TComponentListTests.Last; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TComponentListTests.Insert; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TComponentListTests.Items; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TClassListTests.Setup; 
begin
end;

method TClassListTests.TearDown; 
begin
end;

method TClassListTests.Add; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TClassListTests.Extract; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TClassListTests.Remove; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TClassListTests.IndexOf; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TClassListTests.First; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TClassListTests.Last; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TClassListTests.Insert; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TClassListTests.Items; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TStackTests.Setup; 
begin
end;

method TStackTests.TearDown; 
begin
end;

method TStackTests.Count; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TStackTests.AtLeast; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TStackTests.Push; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TStackTests.Pop; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TStackTests.Peek; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectStackTests.Setup; 
begin
end;

method TObjectStackTests.TearDown; 
begin
end;

method TObjectStackTests.Count; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectStackTests.AtLeast; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectStackTests.Push; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectStackTests.Pop; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectStackTests.Peek; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TQueueTests.Setup; 
begin
end;

method TQueueTests.TearDown; 
begin
end;

method TQueueTests.Count; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TQueueTests.AtLeast; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TQueueTests.Push; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TQueueTests.Pop; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TQueueTests.Peek; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectQueueTests.Setup; 
begin
end;

method TObjectQueueTests.TearDown; 
begin
end;

method TObjectQueueTests.Count; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectQueueTests.AtLeast; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectQueueTests.Push; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectQueueTests.Pop; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TObjectQueueTests.Peek; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TBucketListTests.Setup; 
begin
end;

method TBucketListTests.TearDown; 
begin
end;

method TBucketListTests.Clear; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TBucketListTests.Add; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TBucketListTests.Remove; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TBucketListTests.ForEach; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TBucketListTests.Assign; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TBucketListTests.Exists; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TBucketListTests.Find; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TBucketListTests.Data; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

end.

--- NEW FILE: TestIniFiles.pas ---
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); 
// you may not use this file except in compliance with the License. You may obtain a copy of the 
// License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF 
// ANY KIND, either express or implied. See the License for the specificlanguage governing rights and 
// limitations under the License.

// $Id: TestIniFiles.pas,v 1.1 2005/05/31 08:38:50 peter3 Exp $
namespace NUnit.ShineOn.RTL;

interface
uses
  Nunit.Framework,
  ShineOn.RTL;

type
  [TestFixture]
  TIniFilesTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;
    [Test]
    method Clear;
    [Test]
    method GetStrings;
    [Test]
    method SetStrings;
    [Test]
    method Rename;
    [Test]
    method SectionExists;
    [Test]
    method ReadString;
    [Test]
    method WriteString;
    [Test]
    method ReadInteger;
    [Test]
    method WriteInteger;
    [Test]
    method ReadBool;
    [Test]
    method WriteBool;
    [Test]
    method ReadBinaryStream;
    [Test]
    method ReadDate;
    [Test]
    method ReadDateTime;
    [Test]
    method ReadFloat;
    [Test]
    method ReadTime;
    [Test]
    method WriteBinaryStream;
    [Test]
    method WriteDate;
    [Test]
    method WriteDateTime;
    [Test]
    method WriteFloat;
    [Test]
    method WriteTime;
    [Test]
    method ReadSection;
    [Test]
    method ReadSections;
    [Test]
    method ReadSectionValues;
    [Test]
    method EraseSection;
    [Test]
    method DeleteKey;
    [Test]
    method UpdateFile;
    [Test]
    method ValueExists;
  end;
  
implementation

method TIniFilesTests.Setup; 
begin
end;

method TIniFilesTests.TearDown; 
begin
end;

method TIniFilesTests.Clear; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.GetStrings; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.SetStrings; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.Rename; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.SectionExists; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadString; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.WriteString; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadInteger; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.WriteInteger; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadBool; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.WriteBool; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadBinaryStream; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadDate; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadDateTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadFloat; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.WriteBinaryStream; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.WriteDate; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.WriteDateTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.WriteFloat; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.WriteTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadSection; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadSections; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ReadSectionValues; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.EraseSection; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.DeleteKey; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.UpdateFile; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method TIniFilesTests.ValueExists; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

end.

--- NEW FILE: TestSysUtils.pas ---
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); 
// you may not use this file except in compliance with the License. You may obtain a copy of the 
// License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF 
// ANY KIND, either express or implied. See the License for the specificlanguage governing rights and 
// limitations under the License.

// $Id: TestSysUtils.pas,v 1.1 2005/05/31 08:38:50 peter3 Exp $
namespace NUnit.ShineOn.RTL;

interface
uses
  Nunit.Framework,
  ShineOn.RTL;

type
  [TestFixture]
  SysUtilsTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;
    [Test]
    method AnsiUpperCase;
    [Test]
    method AnsiLowerCase;
    [Test]
    method AnsiCompareStr;
    [Test]
    method AnsiSameStr;
    [Test]
    method AnsiCompareText;
    [Test]
    method AnsiSameText;
    [Test]
    method AnsiStrComp;
    [Test]
    method AnsiStrIComp;
    [Test]
    method AnsiStrLComp;
    [Test]
    method AnsiStrLIComp;
    [Test]
    method AnsiStrLower;
    [Test]
    method AnsiStrUpper;
    [Test]
    method AnsiLastChar;
    [Test]
    method AnsiStrLastChar;
    [Test]
    method WideUpperCase;
    [Test]
    method WideLowerCase;
    [Test]
    method WideCompareStr;
    [Test]
    method WideSameStr;
    [Test]
    method WideCompareText;
    [Test]
    method WideSameText;
    [Test]
    method Trim;
    [Test]
    method TrimLeft;
    [Test]
    method TrimRight;
    [Test]
    method AnsiQuotedStr;
    [Test]
    method AnsiExtractQuotedStr;
    [Test]
    method AnsiDequotedStr;
    [Test]
    method IntToStr;
    [Test]
    method IntToHex;
    [Test]
    method StrToInt;
    [Test]
    method StrToIntDef;
    [Test]
    method TryStrToInt;
    [Test]
    method StrToInt64;
    [Test]
    method StrToInt64Def;
    [Test]
    method TryStrToInt64;
    [Test]
    method StrToBool;
    [Test]
    method BoolToStr;
    [Test]
    method StrToDate;
    [Test]
    method StrToDateDef;
    [Test]
    method StrToDateTime;
    [Test]
    method StrToDateTimeDef;
    [Test]
    method StrToTime;
    [Test]
    method StrToTimeDef;
    [Test]
    method DateToStr;
    [Test]
    method DateTimeToStr;
    [Test]
    method TimeToStr;
    [Test]
    method FreeAndNil;
    [Test]
    method FileExists;
    [Test]
    method DirectoryExists;
    [Test]
    method ForceDirectories;
    [Test]
    method DeleteFile;
    [Test]
    method RenameFile;
    [Test]
    method ChangeFileExt;
    [Test]
    method ExtractFilePath;
    [Test]
    method ExtractFileDir;
    [Test]
    method ExtractFileDrive;
    [Test]
    method ExtractFileName;
    [Test]
    method ExtractFileExt;
    [Test]
    method ExpandFileName;
    [Test]
    method ExpandUNCFileName;
    [Test]
    method ExtractRelativePath;
    [Test]
    method ExtractShortPathName;
    [Test]
    method GetCurrentDir;
    [Test]
    method SetCurrentDir;
    [Test]
    method CreateDir;
    [Test]
    method RemoveDir;
    [Test]
    method IsPathDelimiter;
    [Test]
    method IsDelimiter;
    [Test]
    method IncludeTrailingPathDelimiter;
    [Test]
    method IncludeTrailingBackslash;
    [Test]
    method ExcludeTrailingPathDelimiter;
    [Test]
    method ExcludeTrailingBackslash;
    [Test]
    method LastDelimiter;
    [Test]
    method AnsiCompareFileName;
    [Test]
    method SameFileName;
    [Test]
    method AnsiLowerCaseFileName;
    [Test]
    method AnsiUpperCaseFileName;
    [Test]
    method AnsiPos;
    [Test]
    method AnsiStrPos;
    [Test]
    method AnsiStrRScan;
    [Test]
    method AnsiStrScan;
    [Test]
    method StringReplace;
    [Test]
    method GetEnvironmentVariable;
  end;

implementation

method SysUtilsTests.Setup; 
begin
end;

method SysUtilsTests.TearDown; 
begin
end;

method SysUtilsTests.AnsiUpperCase; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiLowerCase; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiCompareStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiSameStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiCompareText; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiSameText; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrComp; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrIComp; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrLComp; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrLIComp; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrLower; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrUpper; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiLastChar; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrLastChar; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.WideUpperCase; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.WideLowerCase; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.WideCompareStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.WideSameStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.WideCompareText; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.WideSameText; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.Trim; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.TrimLeft; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.TrimRight; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiQuotedStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiExtractQuotedStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiDequotedStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.IntToStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.IntToHex; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToInt; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToIntDef; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.TryStrToInt; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToInt64; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToInt64Def; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.TryStrToInt64; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToBool; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.BoolToStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToDate; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToDateDef; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToDateTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToDateTimeDef; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StrToTimeDef; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.DateToStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.DateTimeToStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.TimeToStr; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.FreeAndNil; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.FileExists; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.DirectoryExists; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ForceDirectories; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.DeleteFile; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.RenameFile; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ChangeFileExt; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExtractFilePath; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExtractFileDir; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExtractFileDrive; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExtractFileName; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExtractFileExt; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExpandFileName; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExpandUNCFileName; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExtractRelativePath; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExtractShortPathName; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.GetCurrentDir; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.SetCurrentDir; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.CreateDir; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.RemoveDir; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.IsPathDelimiter; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.IsDelimiter; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.IncludeTrailingPathDelimiter; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.IncludeTrailingBackslash; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExcludeTrailingPathDelimiter; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.ExcludeTrailingBackslash; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.LastDelimiter; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiCompareFileName; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.SameFileName; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiLowerCaseFileName; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiUpperCaseFileName; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiPos; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrPos; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrRScan; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.AnsiStrScan; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.StringReplace; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SysUtilsTests.GetEnvironmentVariable; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

end.

--- NEW FILE: TestSystem.pas ---
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); 
// you may not use this file except in compliance with the License. You may obtain a copy of the 
// License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF 
// ANY KIND, either express or implied. See the License for the specificlanguage governing rights and 
// limitations under the License.

// $Id: TestSystem.pas,v 1.1 2005/05/31 08:38:50 peter3 Exp $
namespace NUnit.ShineOn.RTL;

interface
uses
  Nunit.Framework,
  ShineOn.RTL;

type
  [TestFixture]
  SystemTests = public class(TestCase)
  public
    method Setup;override;
    method TearDown;override;
    [Test]
    method Pos;
    [Test]
    method Concat;
    [Test]
    method Delete;
    [Test]
    method Insert;
    [Test]
    method Copy;
    [Test]
    method Str;
    [Test]
    method Val;
    [Test]
    method OrdChar;
    [Test]
    method OrdBool;
    [Test]
    method Inc;
    [Test]
    method IncAmount;
    [Test]
    method Dec;
    [Test]
    method DecAmount;
    [Test]
    method Pred;
    [Test]
    method Succ;
    [Test]
    method RoundDouble;
    [Test]
    method RoundTDateTime;
    [Test]
    method TruncDouble;
    [Test]
    method TruncTDateTime;
    [Test]
    method IntDouble;
    [Test]
    method IntTDateTime;
    [Test]
    method FracDouble;
    [Test]
    method FracTDateTime;
    [Test]
    method Odd;
    [Test]
    method Sqrt;
    [Test]
    method SqrExtended;
    [Test]
    method SqrInteger;
    [Test]
    method AbsInteger;
    [Test]
    method AbsDouble;
    [Test]
    method AbsTDateTime;
    [Test]
    method Exp;
    [Test]
    method SetLength;
    [Test]
    method Write;
    [Test]
    method WriteLn;
    [Test]
    method Read;
    [Test]
    method ReadLn;
  end;

implementation

method SystemTests.Setup; 
begin
end;

method SystemTests.TearDown; 
begin
end;

method SystemTests.Pos; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Concat; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Delete; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Insert; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Copy; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Str; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Val; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.OrdChar; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.OrdBool; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Inc; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.IncAmount; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Dec; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.DecAmount; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Pred; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Succ; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.RoundDouble; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.RoundTDateTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.TruncDouble; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.TruncTDateTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.IntDouble; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.IntTDateTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.FracDouble; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.FracTDateTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Odd; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Sqrt; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.SqrExtended; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.SqrInteger; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.AbsInteger; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.AbsDouble; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.AbsTDateTime; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Exp; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.SetLength; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Write; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.WriteLn; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.Read; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

method SystemTests.ReadLn; 
begin
  NUnit.Framework.Assert.IsTrue(false, 'Not implemented');
end;

end.

Index: AssemblyInfo.pas
===================================================================
RCS file: /cvsroot/shineon/ShineOn/NUnit/AssemblyInfo.pas,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** AssemblyInfo.pas	30 May 2005 13:43:32 -0000	1.1
--- AssemblyInfo.pas	31 May 2005 08:38:50 -0000	1.2
***************
*** 1,3 ****
--- 1,24 ----
+ // The contents of this file are subject to the Mozilla Public License Version 1.1 (the "License"); 
+ // you may not use this file except in compliance with the License. You may obtain a copy of the 
+ // License at http://www.mozilla.org/MPL/ 
+ // 
+ // Software distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF 
+ // ANY KIND, either express or implied. See the License for the specificlanguage governing rights and 
+ // limitations under the License.
+ 
+ // $Id$
  namespace NUnit.ShineOn.RTL;
+ // TODO:
+ // - Add test fixtures and methods for all classes and methods
+ // - Implement all tests
+ 
+ // NOTE: you will probably have to change the Start Application path for the project to match the install folder
+ // on your system. You can also run the tests manually from the NUnit GUI (or console) if you prefer.
+ 
+ // To add a NUnit command to the Tools menu, add a new External Tool with these parameters:
+ // Title: NUnit
+ // Command: <path to nunit-gui.exe or nunit-console.exe>
+ // Arguments: $(TargetPath) 
+ // Initial Directory: $(TargetDir)
  
  interface

Index: NUnit.ShineOn.RTL.chrome
===================================================================
RCS file: /cvsroot/shineon/ShineOn/NUnit/NUnit.ShineOn.RTL.chrome,v
retrieving revision 1.1
retrieving revision 1.2
diff -C2 -d -r1.1 -r1.2
*** NUnit.ShineOn.RTL.chrome	30 May 2005 13:43:32 -0000	1.1
--- NUnit.ShineOn.RTL.chrome	31 May 2005 08:38:50 -0000	1.2
***************
*** 68,71 ****
--- 68,91 ----
        <BuildAction>Compile</BuildAction>
      </File>
+     <File Filename="TestClasses.pas">
+       <ExcludeFromBuild>False</ExcludeFromBuild>
+       <BuildAction>Compile</BuildAction>
+     </File>
+     <File Filename="TestContnrs.pas">
+       <ExcludeFromBuild>False</ExcludeFromBuild>
+       <BuildAction>Compile</BuildAction>
+     </File>
+     <File Filename="TestSystem.pas">
+       <ExcludeFromBuild>False</ExcludeFromBuild>
+       <BuildAction>Compile</BuildAction>
+     </File>
+     <File Filename="TestSysUtils.pas">
+       <ExcludeFromBuild>False</ExcludeFromBuild>
+       <BuildAction>Compile</BuildAction>
+     </File>
+     <File Filename="TestIniFiles.pas">
+       <ExcludeFromBuild>False</ExcludeFromBuild>
+       <BuildAction>Compile</BuildAction>
+     </File>
    </Files>
  </ChromeProject>

--- TestMain.pas DELETED ---



From nobody at sheep.berlios.de  Tue May 31 21:58:48 2005
From: nobody at sheep.berlios.de (peter3)
Date: Tue, 31 May 2005 21:58:48 +0200
Subject: [Shineon-checkins] ShineOn/NUnit NUnit.ShineOn.RTL.2005.sln,NONE,1.1 NUnit.ShineOn.RTL.chrome,1.2,1.3
Message-ID: <200505311958.j4VJwmm20914@bat.berlios.de>

Update of /cvsroot/shineon/ShineOn/NUnit
In directory sheep:/tmp/cvs-serv28313/NUnit

Modified Files:
	NUnit.ShineOn.RTL.chrome 
Added Files:
	NUnit.ShineOn.RTL.2005.sln 
Log Message:
- Removed TestMain from project
- Added 2005 solution. NOTE: output format of 2005 assemblies does not work with current version of NUnit (BadFormatException)

--- NEW FILE: NUnit.ShineOn.RTL.2005.sln ---
Microsoft Visual Studio Solution File, Format Version 9.00
# Visual Studio 2005
Project("{656346D9-4656-40DA-A068-22D5425D4639}") = "Nunit.ShineOn.RTL", "Nunit.ShineOn.RTL.chrome", "{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Default = Debug|Default
		Release|Default = Release|Default
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}.Debug|Default.ActiveCfg = Debug
		{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}.Debug|Default.Build.0 = Debug
		{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}.Release|Default.ActiveCfg = Release
		{78329CFC-D7AA-468C-8DF7-DBC4C14D671C}.Release|Default.Build.0 = Release
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

Index: NUnit.ShineOn.RTL.chrome
===================================================================
RCS file: /cvsroot/shineon/ShineOn/NUnit/NUnit.ShineOn.RTL.chrome,v
retrieving revision 1.2
retrieving revision 1.3
diff -C2 -d -r1.2 -r1.3
*** NUnit.ShineOn.RTL.chrome	31 May 2005 08:38:50 -0000	1.2
--- NUnit.ShineOn.RTL.chrome	31 May 2005 19:58:43 -0000	1.3
***************
*** 64,71 ****
        <BuildAction>Compile</BuildAction>
      </File>
-     <File Filename="TestMain.pas">
-       <ExcludeFromBuild>False</ExcludeFromBuild>
-       <BuildAction>Compile</BuildAction>
-     </File>
      <File Filename="TestClasses.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
--- 64,67 ----
***************
*** 76,88 ****
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="TestSystem.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="TestSysUtils.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="TestIniFiles.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
--- 72,84 ----
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="TestIniFiles.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="TestSystem.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>
      </File>
!     <File Filename="TestSysUtils.pas">
        <ExcludeFromBuild>False</ExcludeFromBuild>
        <BuildAction>Compile</BuildAction>



